<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<title>コリドール - 2人対戦</title>
<style>
@import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;900&display=swap');

* { margin: 0; padding: 0; box-sizing: border-box; }

html, body {
  width: 100%; height: 100%;
  overflow: hidden;
  overscroll-behavior: none;
  -webkit-overflow-scrolling: touch;
}

body {
  background: #0c0c1d;
  background-image:
    radial-gradient(ellipse at 20% 50%, rgba(88, 28, 135, 0.15) 0%, transparent 60%),
    radial-gradient(ellipse at 80% 50%, rgba(15, 82, 186, 0.12) 0%, transparent 60%);
  color: #e0e0e0;
  font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
  display: flex;
  justify-content: center;
  align-items: center;
  min-height: 100vh;
  min-height: -webkit-fill-available;
  touch-action: manipulation;
  -webkit-tap-highlight-color: transparent;
  -webkit-touch-callout: none;
  -webkit-user-select: none;
  user-select: none;
}

#app {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 6px;
  padding: 4px;
  padding: 4px calc(4px + env(safe-area-inset-left)) calc(4px + env(safe-area-inset-bottom)) calc(4px + env(safe-area-inset-right));
  width: 100%;
  max-width: 600px;
  height: 100vh;
  height: -webkit-fill-available;
  overflow: hidden;
}

/* ---- Player Zone ---- */
.player-zone {
  width: 100%;
  display: flex;
  flex-direction: column;
  gap: 4px;
  flex-shrink: 0;
}
.player-zone.p2-zone {
  transform: rotate(180deg);
}

/* ---- Player Panels ---- */
.player-panel {
  width: 100%;
  padding: 6px 10px;
  border-radius: 10px;
  background: rgba(255,255,255,0.03);
  border: 2px solid rgba(255,255,255,0.06);
  transition: all 0.4s cubic-bezier(.4,0,.2,1);
  position: relative;
  overflow: hidden;
}
.player-panel::before {
  content: '';
  position: absolute;
  top: 0; left: 0; right: 0;
  height: 3px;
  border-radius: 10px 10px 0 0;
  opacity: 0;
  transition: opacity 0.4s;
}
.player-panel.p1::before { background: linear-gradient(90deg, #ff6b6b, #ee5a24); }
.player-panel.p2::before { background: linear-gradient(90deg, #54a0ff, #2e86de); }
.player-panel.active::before { opacity: 1; }
.player-panel.active.p1 {
  border-color: rgba(238, 90, 36, 0.4);
  box-shadow: 0 0 20px rgba(238, 90, 36, 0.1), inset 0 0 20px rgba(238, 90, 36, 0.03);
}
.player-panel.active.p2 {
  border-color: rgba(46, 134, 222, 0.4);
  box-shadow: 0 0 20px rgba(46, 134, 222, 0.1), inset 0 0 20px rgba(46, 134, 222, 0.03);
}
.panel-row {
  display: flex;
  align-items: center;
  gap: 6px;
}
.player-icon {
  width: 24px; height: 24px;
  border-radius: 7px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 12px;
  font-weight: 900;
  color: white;
  flex-shrink: 0;
}
.player-icon.p1 { background: linear-gradient(135deg, #ff6b6b, #ee5a24); }
.player-icon.p2 { background: linear-gradient(135deg, #54a0ff, #2e86de); }
.player-name {
  font-size: clamp(11px, 2.5vw, 14px);
  font-weight: 700;
  color: #ccc;
  white-space: nowrap;
}
.turn-badge {
  display: inline-block;
  font-size: 9px;
  font-weight: 700;
  padding: 2px 6px;
  border-radius: 4px;
  margin-left: 4px;
  opacity: 0;
  transition: opacity 0.3s;
  letter-spacing: 0.5px;
  flex-shrink: 0;
}
.player-panel.active .turn-badge { opacity: 1; }
.player-panel.p1 .turn-badge { background: rgba(238,90,36,0.3); color: #ff8c5a; }
.player-panel.p2 .turn-badge { background: rgba(46,134,222,0.3); color: #74b9ff; }
.wall-indicators {
  display: flex;
  gap: 3px;
  align-items: center;
  flex-wrap: wrap;
  margin-left: auto;
}
.wall-pip {
  width: 10px; height: 4px;
  border-radius: 2px;
  transition: all 0.3s;
}
.player-panel.p1 .wall-pip { background: rgba(238,90,36,0.5); }
.player-panel.p2 .wall-pip { background: rgba(46,134,222,0.5); }
.wall-pip.used { background: rgba(255,255,255,0.06) !important; }
.wall-label {
  font-size: 9px;
  color: #555;
  margin-left: 3px;
}

/* ---- Timer ---- */
.timer-area {
  display: flex;
  align-items: center;
  gap: 6px;
  margin-top: 3px;
}
.timer-bar-bg {
  flex: 1;
  height: 4px;
  border-radius: 2px;
  background: rgba(255,255,255,0.06);
  overflow: hidden;
}
.timer-bar-fill {
  height: 100%;
  border-radius: 2px;
  transition: width 0.25s linear, background 0.5s;
  width: 100%;
}
.player-panel.p1 .timer-bar-fill { background: linear-gradient(90deg, #ee5a24, #ff6b6b); }
.player-panel.p2 .timer-bar-fill { background: linear-gradient(90deg, #2e86de, #54a0ff); }
.timer-bar-fill.urgent { background: linear-gradient(90deg, #e74c3c, #ff4757) !important; }
.timer-text {
  font-size: 11px;
  font-weight: 700;
  font-variant-numeric: tabular-nums;
  min-width: 22px;
  text-align: right;
  color: #888;
  transition: color 0.3s;
}
.timer-text.urgent { color: #e74c3c; }
.player-panel:not(.active) .timer-area { opacity: 0.3; }

/* ---- Controls ---- */
.controls {
  display: flex;
  align-items: center;
  gap: 5px;
  justify-content: center;
  width: 100%;
}
.ctrl-btn {
  position: relative;
  padding: 8px 14px;
  border: 1px solid rgba(255,255,255,0.1);
  border-radius: 8px;
  background: rgba(255,255,255,0.04);
  color: #999;
  font-family: inherit;
  font-size: 12px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.25s;
  letter-spacing: 0.5px;
  -webkit-tap-highlight-color: transparent;
  touch-action: manipulation;
  min-height: 40px;
}
.ctrl-btn:active { transform: scale(0.95); }
.ctrl-btn.active-move {
  border-color: rgba(46,204,113,0.5);
  color: #2ecc71;
  background: rgba(46,204,113,0.08);
  box-shadow: 0 0 12px rgba(46,204,113,0.1);
}
.ctrl-btn.active-wall {
  border-color: rgba(243,156,18,0.5);
  color: #f39c12;
  background: rgba(243,156,18,0.08);
  box-shadow: 0 0 12px rgba(243,156,18,0.1);
}
.ctrl-btn .kbd {
  display: inline-block;
  font-size: 9px;
  padding: 1px 4px;
  border-radius: 3px;
  background: rgba(255,255,255,0.06);
  color: #666;
  margin-left: 4px;
  font-weight: 400;
  vertical-align: 1px;
}
@media (hover: none) and (pointer: coarse) {
  .ctrl-btn .kbd { display: none; }
}
.ctrl-divider {
  width: 1px;
  height: 24px;
  background: rgba(255,255,255,0.08);
  margin: 0 1px;
}
.orient-group {
  display: flex;
  gap: 4px;
  opacity: 0;
  pointer-events: none;
  transition: opacity 0.25s;
}
.orient-group.visible {
  opacity: 1;
  pointer-events: auto;
}
.orient-btn {
  padding: 8px 12px;
  border: 1px solid rgba(255,255,255,0.08);
  border-radius: 7px;
  background: rgba(255,255,255,0.03);
  color: #777;
  font-family: inherit;
  font-size: 12px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s;
  -webkit-tap-highlight-color: transparent;
  touch-action: manipulation;
  min-height: 40px;
}
.orient-btn:active { transform: scale(0.95); }
.orient-btn.active {
  border-color: rgba(243,156,18,0.4);
  color: #f39c12;
  background: rgba(243,156,18,0.06);
}

/* Inactive player controls */
.controls.inactive {
  opacity: 0.25;
  pointer-events: none;
}

/* ---- Board ---- */
#board-container {
  position: relative;
  -webkit-user-select: none;
  user-select: none;
  touch-action: none;
  width: 100%;
  display: flex;
  justify-content: center;
  flex: 1;
  align-items: center;
  min-height: 0;
}
canvas#board {
  display: block;
  border-radius: 10px;
  cursor: pointer;
  box-shadow:
    0 4px 30px rgba(0,0,0,0.4),
    0 0 60px rgba(88, 28, 135, 0.06);
  max-width: 100%;
  max-height: 100%;
  touch-action: none;
}

/* ---- Center controls (reset/sound) ---- */
.center-controls {
  display: flex;
  gap: 8px;
  align-items: center;
  justify-content: center;
  flex-shrink: 0;
}
.sound-btn {
  width: 38px; height: 38px;
  border: 1px solid rgba(255,255,255,0.08);
  border-radius: 8px;
  background: rgba(255,255,255,0.04);
  color: #888;
  font-size: 16px;
  cursor: pointer;
  transition: all 0.2s;
  display: flex;
  align-items: center;
  justify-content: center;
  -webkit-tap-highlight-color: transparent;
  touch-action: manipulation;
  position: relative;
}
.sound-btn:active { transform: scale(0.9); }
.sound-btn.muted { color: #e74c3c; }
#reset-btn {
  padding: 8px 20px;
  border: 1px solid rgba(255,255,255,0.08);
  border-radius: 8px;
  background: rgba(255,255,255,0.04);
  color: #888;
  font-family: inherit;
  font-size: 12px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.25s;
  -webkit-tap-highlight-color: transparent;
  touch-action: manipulation;
  min-height: 38px;
}
#reset-btn:active { transform: scale(0.95); background: rgba(231,76,60,0.15); }

/* ---- Message ---- */
#message {
  font-size: 11px;
  min-height: 16px;
  text-align: center;
  color: #e17055;
  font-weight: 600;
  letter-spacing: 0.5px;
  flex-shrink: 0;
}

/* ---- Winner Overlay ---- */
.winner-overlay {
  position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;
  background: rgba(0,0,0,0);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 100;
  pointer-events: none;
  transition: background 0.5s;
}
.winner-overlay.show {
  background: rgba(0,0,0,0.7);
  -webkit-backdrop-filter: blur(8px);
  backdrop-filter: blur(8px);
  pointer-events: auto;
}
.winner-box {
  background: #12122a;
  border-radius: 20px;
  padding: 36px 40px;
  text-align: center;
  border: 1px solid rgba(255,255,255,0.08);
  box-shadow: 0 20px 60px rgba(0,0,0,0.5);
  transform: scale(0.8);
  opacity: 0;
  transition: all 0.5s cubic-bezier(.4,0,.2,1);
  margin: 16px;
}
.winner-overlay.show .winner-box {
  transform: scale(1);
  opacity: 1;
}
.winner-box .trophy { font-size: 42px; margin-bottom: 10px; }
.winner-box h2 {
  font-size: clamp(22px, 5vw, 28px);
  font-weight: 900;
  margin-bottom: 8px;
  letter-spacing: 2px;
}
.winner-box .win-p1 { color: #ff6b6b; }
.winner-box .win-p2 { color: #54a0ff; }
.winner-box p { color: #666; font-size: 14px; margin-bottom: 20px; }
.winner-box button {
  padding: 14px 40px;
  border: none;
  border-radius: 12px;
  background: linear-gradient(135deg, #6c5ce7, #a29bfe);
  color: white;
  font-family: inherit;
  font-size: 15px;
  font-weight: 700;
  cursor: pointer;
  letter-spacing: 1px;
  -webkit-tap-highlight-color: transparent;
  touch-action: manipulation;
  min-height: 48px;
}
.winner-box button:active { transform: scale(0.95); }

/* ---- Start Overlay ---- */
.start-overlay {
  position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;
  background: rgba(0,0,0,0.85);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 200;
  -webkit-backdrop-filter: blur(12px);
  backdrop-filter: blur(12px);
}
.start-box { text-align: center; padding: 20px; }
.start-box h2 {
  font-size: clamp(30px, 8vw, 42px);
  font-weight: 900;
  letter-spacing: clamp(6px, 2vw, 12px);
  background: linear-gradient(135deg, #f8cdda, #a0b4f8, #d4fc79);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
  margin-bottom: 16px;
}
.start-box p { color: #666; font-size: 14px; margin-bottom: 32px; }
.start-box button {
  padding: 16px 48px;
  border: none;
  border-radius: 14px;
  background: linear-gradient(135deg, #6c5ce7, #a29bfe);
  color: white;
  font-family: inherit;
  font-size: 18px;
  font-weight: 700;
  cursor: pointer;
  letter-spacing: 2px;
  -webkit-tap-highlight-color: transparent;
  touch-action: manipulation;
  min-height: 52px;
}
.start-box button:active { transform: scale(0.95); }

.hidden { display: none; }
</style>
</head>
<body>

<!-- Start screen -->
<div class="start-overlay" id="start-overlay">
  <div class="start-box">
    <h2>QUORIDOR</h2>
    <p>2 PLAYER STRATEGY GAME</p>
    <button onclick="startGame()">ゲームスタート</button>
  </div>
</div>

<div id="app">
  <!-- P2 zone (top, rotated 180deg for face-to-face play) -->
  <div class="player-zone p2-zone">
    <div class="controls inactive" id="controls-p2">
      <button class="ctrl-btn active-move" id="btn-move-p2" onclick="setMode('move')">
        移動<span class="kbd">M</span>
      </button>
      <button class="ctrl-btn" id="btn-wall-p2" onclick="setMode('wall')">
        壁<span class="kbd">W</span>
      </button>
      <div class="ctrl-divider"></div>
      <div class="orient-group" id="orient-group-p2">
        <button class="orient-btn active" id="btn-h-p2" onclick="setOrientation('h')">横</button>
        <button class="orient-btn" id="btn-v-p2" onclick="setOrientation('v')">縦</button>
      </div>
    </div>
    <div class="player-panel p2" id="p2-panel">
      <div class="panel-row">
        <div class="player-icon p2">2</div>
        <span class="player-name">P2</span>
        <span class="turn-badge">TURN</span>
        <div class="wall-indicators" id="p2-walls"></div>
      </div>
      <div class="timer-area">
        <div class="timer-bar-bg"><div class="timer-bar-fill" id="p2-timer-bar"></div></div>
        <span class="timer-text" id="p2-timer-text">30</span>
      </div>
    </div>
  </div>

  <!-- Board -->
  <div id="board-container">
    <canvas id="board"></canvas>
  </div>

  <div id="message"></div>

  <!-- Center controls -->
  <div class="center-controls">
    <button class="sound-btn" id="sound-btn" onclick="toggleSound()" title="BGM ON/OFF">&#9835;</button>
    <button id="reset-btn" onclick="resetGame()">リセット</button>
  </div>

  <!-- P1 zone (bottom, normal orientation) -->
  <div class="player-zone p1-zone">
    <div class="player-panel p1 active" id="p1-panel">
      <div class="panel-row">
        <div class="player-icon p1">1</div>
        <span class="player-name">P1</span>
        <span class="turn-badge">TURN</span>
        <div class="wall-indicators" id="p1-walls"></div>
      </div>
      <div class="timer-area">
        <div class="timer-bar-bg"><div class="timer-bar-fill" id="p1-timer-bar"></div></div>
        <span class="timer-text" id="p1-timer-text">30</span>
      </div>
    </div>
    <div class="controls" id="controls-p1">
      <button class="ctrl-btn active-move" id="btn-move-p1" onclick="setMode('move')">
        移動<span class="kbd">M</span>
      </button>
      <button class="ctrl-btn" id="btn-wall-p1" onclick="setMode('wall')">
        壁<span class="kbd">W</span>
      </button>
      <div class="ctrl-divider"></div>
      <div class="orient-group" id="orient-group-p1">
        <button class="orient-btn active" id="btn-h-p1" onclick="setOrientation('h')">横</button>
        <button class="orient-btn" id="btn-v-p1" onclick="setOrientation('v')">縦</button>
      </div>
    </div>
  </div>
</div>

<div class="winner-overlay" id="winner-overlay">
  <div class="winner-box">
    <div class="trophy">&#127942;</div>
    <h2 id="winner-text"></h2>
    <p>おめでとうございます！</p>
    <button onclick="resetGame()">もう一度遊ぶ</button>
  </div>
</div>

<script>
// ============ roundRect polyfill for older Safari ============
(function() {
  if (typeof CanvasRenderingContext2D !== 'undefined' &&
      !CanvasRenderingContext2D.prototype.roundRect) {
    CanvasRenderingContext2D.prototype.roundRect = function(x, y, w, h, radii) {
      let r = typeof radii === 'number' ? radii : (Array.isArray(radii) ? radii[0] : 0);
      if (r > w / 2) r = w / 2;
      if (r > h / 2) r = h / 2;
      this.moveTo(x + r, y);
      this.lineTo(x + w - r, y);
      this.quadraticCurveTo(x + w, y, x + w, y + r);
      this.lineTo(x + w, y + h - r);
      this.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
      this.lineTo(x + r, y + h);
      this.quadraticCurveTo(x, y + h, x, y + h - r);
      this.lineTo(x, y + r);
      this.quadraticCurveTo(x, y, x + r, y);
      this.closePath();
      return this;
    };
  }
})();

// ============ CONSTANTS ============
const GRID = 9;
const TURN_TIME = 30;

function calcBoardSize() {
  const vw = window.innerWidth;
  const vh = window.innerHeight;
  const maxBoard = Math.min(vw - 16, vh * 0.46, 520);
  const cellAndGap = maxBoard / (GRID + (GRID - 1) * 0.16 + 0.6);
  const cell = Math.floor(cellAndGap);
  const gap = Math.max(4, Math.round(cell * 0.16));
  const pad = Math.max(8, Math.round(cell * 0.3));
  return { cell, gap, pad };
}

let CELL, GAP, PAD, BOARD_PX, DPR;
const canvas = document.getElementById('board');
const ctx = canvas.getContext('2d');

function resizeBoard() {
  const s = calcBoardSize();
  CELL = s.cell;
  GAP = s.gap;
  PAD = s.pad;
  BOARD_PX = PAD * 2 + GRID * CELL + (GRID - 1) * GAP;
  DPR = window.devicePixelRatio || 1;
  canvas.style.width = BOARD_PX + 'px';
  canvas.style.height = BOARD_PX + 'px';
  canvas.width = Math.round(BOARD_PX * DPR);
  canvas.height = Math.round(BOARD_PX * DPR);
  ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
  draw();
}

// ============ AUDIO ENGINE (Web Audio API) ============
let audioCtx = null;
let bgmPlaying = false;
let bgmMuted = false;
let bgmGain = null;
let bgmTimeout = null;

function initAudio() {
  try {
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    if (audioCtx.state === 'suspended') audioCtx.resume();
    bgmGain = audioCtx.createGain();
    bgmGain.gain.value = 0.18;
    bgmGain.connect(audioCtx.destination);
  } catch (e) {
    console.warn('AudioContext not available', e);
    audioCtx = null;
  }
}

function ensureAudioResumed() {
  if (audioCtx && audioCtx.state === 'suspended') {
    audioCtx.resume();
  }
}

function playNote(freq, startTime, duration, gain, dest, type) {
  if (!audioCtx) return;
  const osc = audioCtx.createOscillator();
  const env = audioCtx.createGain();
  osc.type = type || 'sine';
  osc.frequency.value = freq;
  env.gain.setValueAtTime(0, startTime);
  env.gain.linearRampToValueAtTime(gain, startTime + 0.04);
  env.gain.exponentialRampToValueAtTime(0.001, startTime + duration - 0.02);
  env.gain.setValueAtTime(0, startTime + duration);
  osc.connect(env);
  env.connect(dest);
  osc.start(startTime);
  osc.stop(startTime + duration);
}

const BGM_MELODY = [
  { n: 'E5', d: 0.5 }, { n: 'D5', d: 0.5 }, { n: 'C5', d: 0.5 }, { n: 'B4', d: 0.5 },
  { n: 'A4', d: 0.5 }, { n: 'G4', d: 0.5 }, { n: 'A4', d: 0.5 }, { n: 'B4', d: 0.5 },
  { n: 'C5', d: 0.5 }, { n: 'G4', d: 0.5 }, { n: 'A4', d: 0.5 }, { n: 'E4', d: 0.5 },
  { n: 'F4', d: 0.5 }, { n: 'C4', d: 0.5 }, { n: 'F4', d: 0.5 }, { n: 'G4', d: 0.5 },
  { n: 'A4', d: 0.5 }, { n: 'B4', d: 0.25 }, { n: 'C5', d: 0.25 }, { n: 'D5', d: 0.5 }, { n: 'E5', d: 0.5 },
  { n: 'F5', d: 0.5 }, { n: 'E5', d: 0.25 }, { n: 'D5', d: 0.25 }, { n: 'C5', d: 0.5 }, { n: 'B4', d: 0.5 },
  { n: 'C5', d: 0.75 }, { n: 'D5', d: 0.25 }, { n: 'E5', d: 0.5 }, { n: 'D5', d: 0.25 }, { n: 'C5', d: 0.25 },
  { n: 'B4', d: 0.5 }, { n: 'A4', d: 0.5 }, { n: 'G4', d: 1.0 },
];

const BGM_BASS = [
  { n: 'C3', d: 2 }, { n: 'G2', d: 2 }, { n: 'A2', d: 2 }, { n: 'E2', d: 2 },
  { n: 'F2', d: 2 }, { n: 'C3', d: 2 }, { n: 'F2', d: 2 }, { n: 'G2', d: 2 },
  { n: 'A2', d: 2 }, { n: 'G2', d: 2 }, { n: 'F2', d: 2 }, { n: 'E2', d: 2 },
  { n: 'F2', d: 2 }, { n: 'G2', d: 2 }, { n: 'A2', d: 1 }, { n: 'G2', d: 1 }, { n: 'C3', d: 2 },
];

const NF = {
  'C2': 65.41, 'D2': 73.42, 'E2': 82.41, 'F2': 87.31, 'G2': 98.00, 'A2': 110.0, 'B2': 123.5,
  'C3': 130.8, 'D3': 146.8, 'E3': 164.8, 'F3': 174.6, 'G3': 196.0, 'A3': 220.0, 'B3': 246.9,
  'C4': 261.6, 'D4': 293.7, 'E4': 329.6, 'F4': 349.2, 'G4': 392.0, 'A4': 440.0, 'B4': 493.9,
  'C5': 523.3, 'D5': 587.3, 'E5': 659.3, 'F5': 698.5, 'G5': 784.0, 'A5': 880.0, 'B5': 987.8,
};

function scheduleBGMLoop() {
  if (!audioCtx || bgmMuted) return;
  const tempo = 0.45;
  const now = audioCtx.currentTime + 0.1;
  let t = now;
  for (const note of BGM_MELODY) {
    const dur = note.d * tempo;
    playNote(NF[note.n], t, dur * 0.9, 0.12, bgmGain, 'triangle');
    playNote(NF[note.n] * 2, t, dur * 0.6, 0.03, bgmGain, 'sine');
    t += dur;
  }
  const melodyLen = t - now;
  let tb = now;
  for (const note of BGM_BASS) {
    const dur = note.d * tempo;
    if (tb < now + melodyLen) playNote(NF[note.n], tb, dur * 0.85, 0.08, bgmGain, 'sine');
    tb += dur;
  }
  bgmTimeout = setTimeout(() => {
    if (bgmPlaying && !bgmMuted) scheduleBGMLoop();
  }, melodyLen * 1000 - 100);
}

function startBGM() {
  if (!audioCtx) return;
  bgmPlaying = true;
  bgmMuted = false;
  bgmGain.gain.value = 0.18;
  scheduleBGMLoop();
  updateSoundBtn();
}

function stopBGM() {
  bgmPlaying = false;
  if (bgmTimeout) clearTimeout(bgmTimeout);
  updateSoundBtn();
}

function toggleSound() {
  if (!audioCtx) return;
  ensureAudioResumed();
  bgmMuted = !bgmMuted;
  if (bgmMuted) {
    bgmGain.gain.value = 0;
    if (bgmTimeout) clearTimeout(bgmTimeout);
  } else {
    bgmGain.gain.value = 0.18;
    if (bgmPlaying) scheduleBGMLoop();
  }
  updateSoundBtn();
}

function updateSoundBtn() {
  const btn = document.getElementById('sound-btn');
  btn.classList.toggle('muted', bgmMuted);
  btn.innerHTML = bgmMuted ? '&#9834;<span style="font-size:10px;position:absolute;color:#e74c3c">&#10005;</span>' : '&#9835;';
}

// --- Sound Effects ---
function createNoiseBuffer(duration) {
  if (!audioCtx) return null;
  const len = audioCtx.sampleRate * duration;
  const buf = audioCtx.createBuffer(1, len, audioCtx.sampleRate);
  const data = buf.getChannelData(0);
  for (let i = 0; i < len; i++) data[i] = Math.random() * 2 - 1;
  return buf;
}

function playMoveSFX() {
  if (!audioCtx) return;
  ensureAudioResumed();
  const now = audioCtx.currentTime;
  const noiseSrc = audioCtx.createBufferSource();
  noiseSrc.buffer = createNoiseBuffer(0.12);
  const bp1 = audioCtx.createBiquadFilter();
  bp1.type = 'bandpass';
  bp1.frequency.setValueAtTime(1800, now);
  bp1.frequency.exponentialRampToValueAtTime(600, now + 0.08);
  bp1.Q.value = 2.5;
  const noiseEnv = audioCtx.createGain();
  noiseEnv.gain.setValueAtTime(0.4, now);
  noiseEnv.gain.exponentialRampToValueAtTime(0.001, now + 0.08);
  noiseSrc.connect(bp1); bp1.connect(noiseEnv); noiseEnv.connect(audioCtx.destination);
  noiseSrc.start(now); noiseSrc.stop(now + 0.12);

  const osc = audioCtx.createOscillator();
  osc.type = 'sine';
  osc.frequency.setValueAtTime(420, now);
  osc.frequency.exponentialRampToValueAtTime(280, now + 0.06);
  const oscEnv = audioCtx.createGain();
  oscEnv.gain.setValueAtTime(0.18, now);
  oscEnv.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
  osc.connect(oscEnv); oscEnv.connect(audioCtx.destination);
  osc.start(now); osc.stop(now + 0.1);

  const click = audioCtx.createOscillator();
  click.type = 'triangle';
  click.frequency.setValueAtTime(2400, now);
  click.frequency.exponentialRampToValueAtTime(800, now + 0.02);
  const clickEnv = audioCtx.createGain();
  clickEnv.gain.setValueAtTime(0.12, now);
  clickEnv.gain.exponentialRampToValueAtTime(0.001, now + 0.03);
  click.connect(clickEnv); clickEnv.connect(audioCtx.destination);
  click.start(now); click.stop(now + 0.04);
}

function playWallSFX() {
  if (!audioCtx) return;
  ensureAudioResumed();
  const now = audioCtx.currentTime;
  const noiseSrc = audioCtx.createBufferSource();
  noiseSrc.buffer = createNoiseBuffer(0.25);
  const lp = audioCtx.createBiquadFilter();
  lp.type = 'lowpass';
  lp.frequency.setValueAtTime(2200, now);
  lp.frequency.exponentialRampToValueAtTime(300, now + 0.15);
  lp.Q.value = 1.5;
  const bp = audioCtx.createBiquadFilter();
  bp.type = 'peaking'; bp.frequency.value = 800; bp.Q.value = 3; bp.gain.value = 6;
  const noiseEnv = audioCtx.createGain();
  noiseEnv.gain.setValueAtTime(0.45, now);
  noiseEnv.gain.linearRampToValueAtTime(0.3, now + 0.02);
  noiseEnv.gain.exponentialRampToValueAtTime(0.001, now + 0.2);
  noiseSrc.connect(lp); lp.connect(bp); bp.connect(noiseEnv); noiseEnv.connect(audioCtx.destination);
  noiseSrc.start(now); noiseSrc.stop(now + 0.25);

  const osc = audioCtx.createOscillator();
  osc.type = 'sine';
  osc.frequency.setValueAtTime(220, now);
  osc.frequency.exponentialRampToValueAtTime(80, now + 0.12);
  const oscEnv = audioCtx.createGain();
  oscEnv.gain.setValueAtTime(0.25, now);
  oscEnv.gain.exponentialRampToValueAtTime(0.001, now + 0.18);
  osc.connect(oscEnv); oscEnv.connect(audioCtx.destination);
  osc.start(now); osc.stop(now + 0.2);

  const res = audioCtx.createOscillator();
  res.type = 'triangle';
  res.frequency.setValueAtTime(580, now);
  res.frequency.exponentialRampToValueAtTime(350, now + 0.08);
  const resEnv = audioCtx.createGain();
  resEnv.gain.setValueAtTime(0.12, now);
  resEnv.gain.exponentialRampToValueAtTime(0.001, now + 0.12);
  res.connect(resEnv); resEnv.connect(audioCtx.destination);
  res.start(now); res.stop(now + 0.14);

  const crack = audioCtx.createBufferSource();
  crack.buffer = createNoiseBuffer(0.03);
  const hp = audioCtx.createBiquadFilter();
  hp.type = 'highpass'; hp.frequency.value = 3000; hp.Q.value = 0.5;
  const crackEnv = audioCtx.createGain();
  crackEnv.gain.setValueAtTime(0.2, now);
  crackEnv.gain.exponentialRampToValueAtTime(0.001, now + 0.025);
  crack.connect(hp); hp.connect(crackEnv); crackEnv.connect(audioCtx.destination);
  crack.start(now); crack.stop(now + 0.03);
}

function playTimerWarnSFX() {
  if (!audioCtx) return;
  const now = audioCtx.currentTime;
  const osc = audioCtx.createOscillator();
  const env = audioCtx.createGain();
  osc.type = 'sine'; osc.frequency.value = 880;
  env.gain.setValueAtTime(0.15, now);
  env.gain.exponentialRampToValueAtTime(0.001, now + 0.12);
  osc.connect(env); env.connect(audioCtx.destination);
  osc.start(now); osc.stop(now + 0.12);
}

function playTimeoutSFX() {
  if (!audioCtx) return;
  const now = audioCtx.currentTime;
  for (let i = 0; i < 3; i++) {
    const osc = audioCtx.createOscillator();
    const env = audioCtx.createGain();
    osc.type = 'triangle'; osc.frequency.value = 600 - i * 150;
    env.gain.setValueAtTime(0.18, now + i * 0.15);
    env.gain.exponentialRampToValueAtTime(0.001, now + i * 0.15 + 0.14);
    osc.connect(env); env.connect(audioCtx.destination);
    osc.start(now + i * 0.15); osc.stop(now + i * 0.15 + 0.15);
  }
}

function playWinSFX() {
  if (!audioCtx) return;
  const now = audioCtx.currentTime;
  [523.3, 659.3, 784.0, 1047].forEach((freq, i) => {
    const osc = audioCtx.createOscillator();
    const env = audioCtx.createGain();
    osc.type = 'triangle'; osc.frequency.value = freq;
    const t = now + i * 0.15;
    env.gain.setValueAtTime(0, t);
    env.gain.linearRampToValueAtTime(0.2, t + 0.04);
    env.gain.exponentialRampToValueAtTime(0.01, t + 0.5);
    osc.connect(env); env.connect(audioCtx.destination);
    osc.start(t); osc.stop(t + 0.5);
    const osc2 = audioCtx.createOscillator();
    const env2 = audioCtx.createGain();
    osc2.type = 'sine'; osc2.frequency.value = freq * 1.5;
    env2.gain.setValueAtTime(0, t);
    env2.gain.linearRampToValueAtTime(0.07, t + 0.04);
    env2.gain.exponentialRampToValueAtTime(0.001, t + 0.4);
    osc2.connect(env2); env2.connect(audioCtx.destination);
    osc2.start(t); osc2.stop(t + 0.4);
  });
}

// ============ STATE ============
let players, walls, wallCounts, currentPlayer, mode, orientation, gameOver, hoverWall;
let turnTimeLeft, timerInterval, gameStarted;

function initState() {
  players = [{ row: 8, col: 4 }, { row: 0, col: 4 }];
  walls = [];
  wallCounts = [10, 10];
  currentPlayer = 0;
  mode = 'move';
  orientation = 'h';
  gameOver = false;
  hoverWall = null;
  turnTimeLeft = TURN_TIME;
  gameStarted = false;
}

// ============ TIMER ============
function startTurnTimer() {
  turnTimeLeft = TURN_TIME;
  clearInterval(timerInterval);
  let lastWarnAt = -1;
  timerInterval = setInterval(() => {
    if (gameOver) { clearInterval(timerInterval); return; }
    turnTimeLeft -= 0.25;
    if (turnTimeLeft <= 0) {
      turnTimeLeft = 0;
      clearInterval(timerInterval);
      onTimeout();
    }
    const sec = Math.ceil(turnTimeLeft);
    if (sec <= 5 && sec !== lastWarnAt && turnTimeLeft > 0) {
      lastWarnAt = sec;
      playTimerWarnSFX();
    }
    updateTimerUI();
  }, 250);
}

function onTimeout() {
  playTimeoutSFX();
  showMsg('時間切れ！ターンをスキップしました');
  currentPlayer = 1 - currentPlayer;
  mode = 'move';
  hoverWall = null;
  updateUI();
  draw();
  startTurnTimer();
}

function updateTimerUI() {
  const sec = Math.ceil(turnTimeLeft);
  const pct = (turnTimeLeft / TURN_TIME) * 100;
  const urgent = turnTimeLeft <= 5;
  for (let p = 0; p < 2; p++) {
    const bar = document.getElementById('p' + (p+1) + '-timer-bar');
    const txt = document.getElementById('p' + (p+1) + '-timer-text');
    if (p === currentPlayer) {
      bar.style.width = pct + '%';
      bar.classList.toggle('urgent', urgent);
      txt.textContent = sec;
      txt.classList.toggle('urgent', urgent);
    } else {
      bar.style.width = '100%';
      bar.classList.remove('urgent');
      txt.textContent = '30';
      txt.classList.remove('urgent');
    }
  }
}

// ============ COORDINATE HELPERS ============
function cellX(col) { return PAD + col * (CELL + GAP); }
function cellY(row) { return PAD + row * (CELL + GAP); }

function pixelToCell(px, py) {
  for (let r = 0; r < GRID; r++) {
    for (let c = 0; c < GRID; c++) {
      const x = cellX(c), y = cellY(r);
      if (px >= x && px < x + CELL && py >= y && py < y + CELL) return { row: r, col: c };
    }
  }
  return null;
}

function pixelToWallSlot(px, py) {
  const dist = Math.max(CELL * 0.55, 24);
  for (let r = 0; r < GRID - 1; r++) {
    for (let c = 0; c < GRID - 1; c++) {
      const cx = cellX(c) + CELL + GAP / 2;
      const cy = cellY(r) + CELL + GAP / 2;
      if (Math.abs(px - cx) < dist && Math.abs(py - cy) < dist) return { row: r, col: c };
    }
  }
  return null;
}

// ============ WALL LOGIC ============
function isBlocked(r1, c1, r2, c2) {
  const dr = r2 - r1, dc = c2 - c1;
  for (const w of walls) {
    if (dr === -1 && dc === 0 && w.orient === 'h' && w.row === r1 - 1 && (w.col === c1 || w.col === c1 - 1)) return true;
    if (dr === 1  && dc === 0 && w.orient === 'h' && w.row === r1     && (w.col === c1 || w.col === c1 - 1)) return true;
    if (dc === -1 && dr === 0 && w.orient === 'v' && w.col === c1 - 1 && (w.row === r1 || w.row === r1 - 1)) return true;
    if (dc === 1  && dr === 0 && w.orient === 'v' && w.col === c1     && (w.row === r1 || w.row === r1 - 1)) return true;
  }
  return false;
}

function wallOverlaps(r, c, o) {
  for (const w of walls) {
    if (w.orient === o && o === 'h' && w.row === r && Math.abs(w.col - c) <= 1) return true;
    if (w.orient === o && o === 'v' && w.col === c && Math.abs(w.row - r) <= 1) return true;
    if (w.row === r && w.col === c && w.orient !== o) return true;
  }
  return false;
}

function canReachGoal(p, extraWalls) {
  const goalRow = p === 0 ? 0 : 8;
  const allWalls = walls.concat(extraWalls || []);
  const visited = Array.from({ length: GRID }, () => Array(GRID).fill(false));
  const queue = [{ row: players[p].row, col: players[p].col }];
  visited[players[p].row][players[p].col] = true;
  function blocked(r1, c1, r2, c2) {
    const dr = r2 - r1, dc = c2 - c1;
    for (const w of allWalls) {
      if (dr === -1 && dc === 0 && w.orient === 'h' && w.row === r1 - 1 && (w.col === c1 || w.col === c1 - 1)) return true;
      if (dr === 1  && dc === 0 && w.orient === 'h' && w.row === r1     && (w.col === c1 || w.col === c1 - 1)) return true;
      if (dc === -1 && dr === 0 && w.orient === 'v' && w.col === c1 - 1 && (w.row === r1 || w.row === r1 - 1)) return true;
      if (dc === 1  && dr === 0 && w.orient === 'v' && w.col === c1     && (w.row === r1 || w.row === r1 - 1)) return true;
    }
    return false;
  }
  while (queue.length) {
    const { row, col } = queue.shift();
    if (row === goalRow) return true;
    for (const [dr, dc] of [[-1,0],[1,0],[0,-1],[0,1]]) {
      const nr = row + dr, nc = col + dc;
      if (nr < 0 || nr >= GRID || nc < 0 || nc >= GRID) continue;
      if (visited[nr][nc]) continue;
      if (blocked(row, col, nr, nc)) continue;
      visited[nr][nc] = true;
      queue.push({ row: nr, col: nc });
    }
  }
  return false;
}

function canPlaceWall(r, c, o) {
  if (r < 0 || r >= GRID - 1 || c < 0 || c >= GRID - 1) return false;
  if (wallOverlaps(r, c, o)) return false;
  const tw = { row: r, col: c, orient: o };
  return canReachGoal(0, [tw]) && canReachGoal(1, [tw]);
}

// ============ MOVEMENT LOGIC ============
function getValidMoves(p) {
  const { row, col } = players[p];
  const opp = players[1 - p];
  const moves = [];
  for (const [dr, dc] of [[-1,0],[1,0],[0,-1],[0,1]]) {
    const nr = row + dr, nc = col + dc;
    if (nr < 0 || nr >= GRID || nc < 0 || nc >= GRID) continue;
    if (isBlocked(row, col, nr, nc)) continue;
    if (opp.row === nr && opp.col === nc) {
      const jr = nr + dr, jc = nc + dc;
      if (jr >= 0 && jr < GRID && jc >= 0 && jc < GRID && !isBlocked(nr, nc, jr, jc)) {
        moves.push({ row: jr, col: jc });
      } else {
        for (const [dr2, dc2] of [[-1,0],[1,0],[0,-1],[0,1]]) {
          if (dr2 === -dr && dc2 === -dc) continue;
          const djr = nr + dr2, djc = nc + dc2;
          if (djr < 0 || djr >= GRID || djc < 0 || djc >= GRID) continue;
          if (isBlocked(nr, nc, djr, djc)) continue;
          moves.push({ row: djr, col: djc });
        }
      }
    } else {
      moves.push({ row: nr, col: nc });
    }
  }
  return moves;
}

// ============ DRAWING ============
function draw() {
  ctx.clearRect(0, 0, BOARD_PX, BOARD_PX);

  const bg = ctx.createLinearGradient(0, 0, BOARD_PX, BOARD_PX);
  bg.addColorStop(0, '#111128');
  bg.addColorStop(1, '#0d1b2a');
  ctx.fillStyle = bg;
  ctx.beginPath();
  ctx.roundRect(0, 0, BOARD_PX, BOARD_PX, 12);
  ctx.fill();

  ctx.strokeStyle = 'rgba(255,255,255,0.04)';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.roundRect(0.5, 0.5, BOARD_PX - 1, BOARD_PX - 1, 12);
  ctx.stroke();

  const cr = Math.max(3, CELL * 0.12);
  for (let r = 0; r < GRID; r++) {
    for (let c = 0; c < GRID; c++) {
      ctx.fillStyle = 'rgba(255,255,255,0.03)';
      ctx.beginPath();
      ctx.roundRect(cellX(c), cellY(r), CELL, CELL, cr);
      ctx.fill();
    }
  }

  // Goal rows
  for (let c = 0; c < GRID; c++) {
    const g1 = ctx.createLinearGradient(0, cellY(0), 0, cellY(0) + CELL);
    g1.addColorStop(0, 'rgba(238, 90, 36, 0.12)');
    g1.addColorStop(1, 'rgba(238, 90, 36, 0.04)');
    ctx.fillStyle = g1;
    ctx.beginPath(); ctx.roundRect(cellX(c), cellY(0), CELL, CELL, cr); ctx.fill();

    const g2 = ctx.createLinearGradient(0, cellY(8), 0, cellY(8) + CELL);
    g2.addColorStop(0, 'rgba(46, 134, 222, 0.04)');
    g2.addColorStop(1, 'rgba(46, 134, 222, 0.12)');
    ctx.fillStyle = g2;
    ctx.beginPath(); ctx.roundRect(cellX(c), cellY(8), CELL, CELL, cr); ctx.fill();
  }

  // Valid moves
  if (!gameOver && mode === 'move') {
    const moves = getValidMoves(currentPlayer);
    for (const m of moves) {
      const x = cellX(m.col), y = cellY(m.row);
      ctx.fillStyle = 'rgba(46, 204, 113, 0.15)';
      ctx.beginPath(); ctx.roundRect(x, y, CELL, CELL, cr); ctx.fill();
      ctx.strokeStyle = 'rgba(46, 204, 113, 0.45)';
      ctx.lineWidth = 2;
      ctx.setLineDash([4, 3]);
      ctx.beginPath(); ctx.roundRect(x + 1, y + 1, CELL - 2, CELL - 2, cr); ctx.stroke();
      ctx.setLineDash([]);
      ctx.fillStyle = 'rgba(46, 204, 113, 0.5)';
      ctx.beginPath(); ctx.arc(x + CELL / 2, y + CELL / 2, Math.max(3, CELL * 0.08), 0, Math.PI * 2); ctx.fill();
    }
  }

  for (const w of walls) drawWall(w.row, w.col, w.orient);
  if (hoverWall && !gameOver) {
    drawWallPreview(hoverWall.row, hoverWall.col, hoverWall.orient, canPlaceWall(hoverWall.row, hoverWall.col, hoverWall.orient));
  }

  drawPlayer(players[0], 0);
  drawPlayer(players[1], 1);
}

function drawWall(r, c, orient) {
  ctx.save();
  const wr = Math.max(2, GAP * 0.4);
  if (orient === 'h') {
    const x = cellX(c), y = cellY(r) + CELL, w = CELL * 2 + GAP, h = GAP;
    const grad = ctx.createLinearGradient(x, y, x + w, y);
    grad.addColorStop(0, '#f0c040'); grad.addColorStop(0.5, '#e2b714'); grad.addColorStop(1, '#d4a010');
    ctx.fillStyle = grad;
    ctx.shadowColor = 'rgba(226, 183, 20, 0.35)'; ctx.shadowBlur = 8;
    ctx.beginPath(); ctx.roundRect(x, y, w, h, wr); ctx.fill();
  } else {
    const x = cellX(c) + CELL, y = cellY(r), w = GAP, h = CELL * 2 + GAP;
    const grad = ctx.createLinearGradient(x, y, x, y + h);
    grad.addColorStop(0, '#f0c040'); grad.addColorStop(0.5, '#e2b714'); grad.addColorStop(1, '#d4a010');
    ctx.fillStyle = grad;
    ctx.shadowColor = 'rgba(226, 183, 20, 0.35)'; ctx.shadowBlur = 8;
    ctx.beginPath(); ctx.roundRect(x, y, w, h, wr); ctx.fill();
  }
  ctx.restore();
}

function drawWallPreview(r, c, orient, valid) {
  ctx.save();
  ctx.globalAlpha = 0.6;
  const color = valid ? 'rgba(46, 204, 113, 0.8)' : 'rgba(231, 76, 60, 0.8)';
  ctx.fillStyle = color; ctx.shadowColor = color; ctx.shadowBlur = 10;
  const wr = Math.max(2, GAP * 0.4);
  if (orient === 'h') {
    ctx.beginPath(); ctx.roundRect(cellX(c), cellY(r) + CELL, CELL * 2 + GAP, GAP, wr); ctx.fill();
  } else {
    ctx.beginPath(); ctx.roundRect(cellX(c) + CELL, cellY(r), GAP, CELL * 2 + GAP, wr); ctx.fill();
  }
  ctx.restore();
}

function drawPlayer(p, idx) {
  const cx = cellX(p.col) + CELL / 2;
  const cy = cellY(p.row) + CELL / 2;
  const isActive = currentPlayer === idx && !gameOver;
  const pr = CELL * 0.36;
  const colors = idx === 0
    ? { main: '#ee5a24', light: '#ff6b6b', glow: 'rgba(238,90,36,' }
    : { main: '#2e86de', light: '#54a0ff', glow: 'rgba(46,134,222,' };

  ctx.save();
  if (isActive) {
    const gg = ctx.createRadialGradient(cx, cy, pr * 0.4, cx, cy, pr * 1.8);
    gg.addColorStop(0, colors.glow + '0.25)');
    gg.addColorStop(1, colors.glow + '0)');
    ctx.fillStyle = gg;
    ctx.beginPath(); ctx.arc(cx, cy, pr * 1.8, 0, Math.PI * 2); ctx.fill();
  }
  ctx.shadowColor = colors.glow + '0.4)';
  ctx.shadowBlur = isActive ? pr * 0.9 : pr * 0.35;
  const grad = ctx.createRadialGradient(cx - pr * 0.2, cy - pr * 0.2, pr * 0.1, cx, cy, pr);
  grad.addColorStop(0, colors.light);
  grad.addColorStop(1, colors.main);
  ctx.fillStyle = grad;
  ctx.beginPath(); ctx.arc(cx, cy, pr, 0, Math.PI * 2); ctx.fill();
  ctx.shadowColor = 'transparent';
  ctx.strokeStyle = 'rgba(255,255,255,0.25)';
  ctx.lineWidth = 1.5;
  ctx.beginPath(); ctx.arc(cx, cy, pr, 0, Math.PI * 2); ctx.stroke();
  ctx.fillStyle = 'rgba(255,255,255,0.15)';
  ctx.beginPath(); ctx.arc(cx - pr * 0.28, cy - pr * 0.28, pr * 0.38, 0, Math.PI * 2); ctx.fill();
  ctx.restore();
}

// ============ UI ============
function renderWallPips(containerId, count) {
  const el = document.getElementById(containerId);
  let html = '';
  for (let i = 0; i < 10; i++) html += '<div class="wall-pip' + (i >= count ? ' used' : '') + '"></div>';
  html += '<span class="wall-label">' + count + '</span>';
  el.innerHTML = html;
}

function updateUI() {
  document.getElementById('p1-panel').classList.toggle('active', currentPlayer === 0);
  document.getElementById('p2-panel').classList.toggle('active', currentPlayer === 1);
  renderWallPips('p1-walls', wallCounts[0]);
  renderWallPips('p2-walls', wallCounts[1]);

  // Update both sets of controls
  for (var pIdx = 0; pIdx < 2; pIdx++) {
    var suffix = pIdx === 0 ? '-p1' : '-p2';
    var controlsEl = document.getElementById('controls' + suffix);
    controlsEl.classList.toggle('inactive', currentPlayer !== pIdx);

    document.getElementById('btn-move' + suffix).className = 'ctrl-btn' + (mode === 'move' ? ' active-move' : '');
    document.getElementById('btn-wall' + suffix).className = 'ctrl-btn' + (mode === 'wall' ? ' active-wall' : '');
    document.getElementById('orient-group' + suffix).classList.toggle('visible', mode === 'wall');
    document.getElementById('btn-h' + suffix).classList.toggle('active', orientation === 'h');
    document.getElementById('btn-v' + suffix).classList.toggle('active', orientation === 'v');
  }

  updateTimerUI();
}

function setMode(m) {
  if (gameOver) return;
  mode = m;
  hoverWall = null;
  showMsg('');
  updateUI();
  draw();
}

function setOrientation(o) {
  orientation = o;
  hoverWall = null;
  updateUI();
  draw();
}

function showMsg(text) {
  document.getElementById('message').textContent = text;
}

function showWinner(p) {
  gameOver = true;
  clearInterval(timerInterval);
  stopBGM();
  playWinSFX();
  const overlay = document.getElementById('winner-overlay');
  const text = document.getElementById('winner-text');
  text.className = p === 0 ? 'win-p1' : 'win-p2';
  text.textContent = 'プレイヤー ' + (p + 1) + ' の勝利！';
  requestAnimationFrame(function() { overlay.classList.add('show'); });
}

function startGame() {
  document.getElementById('start-overlay').classList.add('hidden');
  initAudio();
  initState();
  gameStarted = true;
  resizeBoard();
  showMsg('');
  updateUI();
  draw();
  startBGM();
  startTurnTimer();
}

function resetGame() {
  document.getElementById('winner-overlay').classList.remove('show');
  clearInterval(timerInterval);
  // AudioContextごとリセットして音の重なりを防止
  if (bgmTimeout) clearTimeout(bgmTimeout);
  bgmPlaying = false;
  if (audioCtx) {
    audioCtx.close().catch(function(){});
    audioCtx = null;
  }
  initState();
  gameStarted = true;
  showMsg('');
  updateUI();
  draw();
  initAudio();
  startBGM();
  startTurnTimer();
}

// ============ TOUCH & POINTER HELPERS ============
function getCanvasPos(e) {
  const rect = canvas.getBoundingClientRect();
  const scaleX = BOARD_PX / rect.width;
  const scaleY = BOARD_PX / rect.height;
  let clientX, clientY;
  if (e.touches && e.touches.length > 0) {
    clientX = e.touches[0].clientX;
    clientY = e.touches[0].clientY;
  } else if (e.changedTouches && e.changedTouches.length > 0) {
    clientX = e.changedTouches[0].clientX;
    clientY = e.changedTouches[0].clientY;
  } else {
    clientX = e.clientX;
    clientY = e.clientY;
  }
  return {
    px: (clientX - rect.left) * scaleX,
    py: (clientY - rect.top) * scaleY
  };
}

function handleBoardAction(px, py) {
  if (gameOver || !gameStarted) return;
  ensureAudioResumed();

  if (mode === 'move') {
    const cell = pixelToCell(px, py);
    if (!cell) return;
    const moves = getValidMoves(currentPlayer);
    const match = moves.find(function(m) { return m.row === cell.row && m.col === cell.col; });
    if (!match) { showMsg('そこには移動できません'); return; }
    players[currentPlayer].row = match.row;
    players[currentPlayer].col = match.col;
    playMoveSFX();
    showMsg('');
    if (currentPlayer === 0 && players[0].row === 0) { draw(); updateUI(); showWinner(0); return; }
    if (currentPlayer === 1 && players[1].row === 8) { draw(); updateUI(); showWinner(1); return; }
    currentPlayer = 1 - currentPlayer;
    updateUI(); draw(); startTurnTimer();
  } else {
    const slot = pixelToWallSlot(px, py);
    if (!slot) { showMsg('壁の交差点付近をタップしてください'); return; }
    if (wallCounts[currentPlayer] <= 0) { showMsg('壁を使い切りました'); return; }
    if (!canPlaceWall(slot.row, slot.col, orientation)) { showMsg('そこには壁を置けません'); return; }
    walls.push({ row: slot.row, col: slot.col, orient: orientation });
    wallCounts[currentPlayer]--;
    playWallSFX();
    showMsg('');
    mode = 'move';
    hoverWall = null;
    currentPlayer = 1 - currentPlayer;
    updateUI(); draw(); startTurnTimer();
  }
}

// ============ EVENTS ============
// Mouse events (desktop)
canvas.addEventListener('click', function(e) {
  const pos = getCanvasPos(e);
  handleBoardAction(pos.px, pos.py);
});

canvas.addEventListener('mousemove', function(e) {
  if (gameOver || mode !== 'wall') {
    if (hoverWall) { hoverWall = null; draw(); }
    return;
  }
  const pos = getCanvasPos(e);
  const slot = pixelToWallSlot(pos.px, pos.py);
  hoverWall = slot ? { row: slot.row, col: slot.col, orient: orientation } : null;
  draw();
});

canvas.addEventListener('mouseleave', function() {
  hoverWall = null;
  draw();
});

// Touch events (mobile)
let touchStartPos = null;
canvas.addEventListener('touchstart', function(e) {
  e.preventDefault();
  touchStartPos = getCanvasPos(e);
}, { passive: false });

canvas.addEventListener('touchmove', function(e) {
  e.preventDefault();
  if (mode === 'wall' && !gameOver) {
    const pos = getCanvasPos(e);
    const slot = pixelToWallSlot(pos.px, pos.py);
    hoverWall = slot ? { row: slot.row, col: slot.col, orient: orientation } : null;
    draw();
  }
}, { passive: false });

canvas.addEventListener('touchend', function(e) {
  e.preventDefault();
  if (!touchStartPos) return;
  const endPos = getCanvasPos(e);
  const dx = endPos.px - touchStartPos.px;
  const dy = endPos.py - touchStartPos.py;
  if (Math.abs(dx) < CELL * 1.5 && Math.abs(dy) < CELL * 1.5) {
    handleBoardAction(endPos.px, endPos.py);
  }
  hoverWall = null;
  touchStartPos = null;
  draw();
}, { passive: false });

canvas.addEventListener('touchcancel', function() {
  hoverWall = null;
  touchStartPos = null;
  draw();
});

// Prevent pull-to-refresh / bounce
document.addEventListener('touchmove', function(e) {
  if (e.target === canvas || canvas.contains(e.target)) {
    e.preventDefault();
  }
}, { passive: false });

// Keyboard shortcuts
document.addEventListener('keydown', function(e) {
  if (!gameStarted) return;
  if (e.key === 'm' || e.key === 'M') setMode('move');
  if (e.key === 'w' || e.key === 'W') setMode('wall');
  if (e.key === 'h' || e.key === 'H') setOrientation('h');
  if (e.key === 'v' || e.key === 'V') setOrientation('v');
  if (e.key === 'r' || e.key === 'R') resetGame();
});

// Resize handler
let resizeTimer;
window.addEventListener('resize', function() {
  clearTimeout(resizeTimer);
  resizeTimer = setTimeout(function() {
    if (gameStarted) { resizeBoard(); }
  }, 150);
});
window.addEventListener('orientationchange', function() {
  setTimeout(function() { if (gameStarted) resizeBoard(); }, 300);
});

// ============ INIT ============
initState();
resizeBoard();
updateUI();
draw();
</script>
</body>
</html>
