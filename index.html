<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="apple-mobile-web-app-title" content="コリドール">
<meta name="theme-color" content="#020810">
<meta name="description" content="2人で遊べる戦略ボードゲーム コリドール">
<link rel="manifest" href="manifest.json">
<link rel="icon" type="image/png" sizes="192x192" href="icon-192.png">
<link rel="apple-touch-icon" href="icon-192.png">
<title>コリドール - GALACTIC DUEL</title>
<style>
@import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;600;700;900&family=Inter:wght@400;600;700;900&display=swap');

* { margin: 0; padding: 0; box-sizing: border-box; }

html, body {
  width: 100%; height: 100%;
  overflow: hidden;
  overscroll-behavior: none;
  -webkit-overflow-scrolling: touch;
}

body {
  background: #020810;
  color: #c0d0e8;
  font-family: 'Orbitron', 'Inter', -apple-system, sans-serif;
  display: flex;
  justify-content: center;
  align-items: center;
  min-height: 100vh;
  min-height: -webkit-fill-available;
  touch-action: manipulation;
  -webkit-tap-highlight-color: transparent;
  -webkit-touch-callout: none;
  -webkit-user-select: none;
  user-select: none;
  position: relative;
  overflow: hidden;
}

/* Star field */
body::before {
  content: '';
  position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;
  background:
    radial-gradient(1px 1px at 10% 20%, rgba(255,255,255,0.8), transparent),
    radial-gradient(1px 1px at 25% 45%, rgba(255,255,255,0.6), transparent),
    radial-gradient(1px 1px at 40% 15%, rgba(255,255,255,0.5), transparent),
    radial-gradient(1px 1px at 55% 70%, rgba(255,255,255,0.7), transparent),
    radial-gradient(1px 1px at 70% 35%, rgba(255,255,255,0.4), transparent),
    radial-gradient(1px 1px at 85% 80%, rgba(255,255,255,0.6), transparent),
    radial-gradient(1px 1px at 15% 85%, rgba(255,255,255,0.5), transparent),
    radial-gradient(1px 1px at 90% 10%, rgba(255,255,255,0.8), transparent),
    radial-gradient(1px 1px at 5% 60%, rgba(255,255,255,0.3), transparent),
    radial-gradient(1px 1px at 48% 90%, rgba(255,255,255,0.5), transparent),
    radial-gradient(1px 1px at 62% 52%, rgba(255,255,255,0.6), transparent),
    radial-gradient(1px 1px at 78% 65%, rgba(255,255,255,0.4), transparent),
    radial-gradient(1px 1px at 33% 33%, rgba(255,255,255,0.7), transparent),
    radial-gradient(1px 1px at 95% 50%, rgba(255,255,255,0.5), transparent),
    radial-gradient(2px 2px at 20% 72%, rgba(150,180,255,0.8), transparent),
    radial-gradient(2px 2px at 75% 22%, rgba(255,200,150,0.7), transparent),
    radial-gradient(2px 2px at 50% 50%, rgba(200,150,255,0.6), transparent);
  animation: twinkle 4s ease-in-out infinite alternate;
  pointer-events: none;
  z-index: 0;
}
@keyframes twinkle {
  0% { opacity: 0.7; }
  100% { opacity: 1; }
}

/* Nebula glow */
body::after {
  content: '';
  position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;
  background:
    radial-gradient(ellipse at 15% 50%, rgba(255, 0, 0, 0.04) 0%, transparent 50%),
    radial-gradient(ellipse at 85% 50%, rgba(0, 100, 255, 0.04) 0%, transparent 50%);
  pointer-events: none;
  z-index: 0;
}

#app {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  gap: 4px;
  padding: calc(4px + env(safe-area-inset-top)) calc(4px + env(safe-area-inset-right)) calc(4px + env(safe-area-inset-bottom)) calc(4px + env(safe-area-inset-left));
  width: 100%;
  max-width: 600px;
  height: 100vh;
  height: 100dvh;
  overflow: hidden;
  position: relative;
  z-index: 1;
}

/* ---- Player Zone ---- */
.player-zone {
  width: 100%;
  display: flex;
  flex-direction: column;
  gap: 4px;
  flex-shrink: 0;
}
.player-zone.p2-zone {
  transform: rotate(180deg);
}

/* ---- Player Panels ---- */
.player-panel {
  width: 100%;
  padding: 6px 10px;
  border-radius: 6px;
  background: rgba(10,20,40,0.7);
  border: 1px solid rgba(100,150,255,0.1);
  transition: all 0.4s cubic-bezier(.4,0,.2,1);
  position: relative;
  overflow: hidden;
}
.player-panel::before {
  content: '';
  position: absolute;
  top: 0; left: 0; right: 0;
  height: 2px;
  opacity: 0;
  transition: opacity 0.4s;
}
.player-panel.p1::before { background: linear-gradient(90deg, #ff0000, #ff4444, #ff0000); box-shadow: 0 0 10px #ff0000; }
.player-panel.p2::before { background: linear-gradient(90deg, #0066ff, #44aaff, #0066ff); box-shadow: 0 0 10px #0066ff; }
.player-panel.active::before { opacity: 1; }
.player-panel.active.p1 {
  border-color: rgba(255, 0, 0, 0.3);
  box-shadow: 0 0 20px rgba(255, 0, 0, 0.08), inset 0 0 20px rgba(255, 0, 0, 0.03);
}
.player-panel.active.p2 {
  border-color: rgba(0, 100, 255, 0.3);
  box-shadow: 0 0 20px rgba(0, 100, 255, 0.08), inset 0 0 20px rgba(0, 100, 255, 0.03);
}
.panel-row {
  display: flex;
  align-items: center;
  gap: 6px;
}
.player-icon {
  width: 24px; height: 24px;
  border-radius: 4px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 11px;
  font-weight: 900;
  color: white;
  flex-shrink: 0;
  letter-spacing: 0;
}
.player-icon.p1 { background: linear-gradient(135deg, #cc0000, #ff2222); box-shadow: 0 0 8px rgba(255,0,0,0.3); }
.player-icon.p2 { background: linear-gradient(135deg, #0044cc, #2288ff); box-shadow: 0 0 8px rgba(0,100,255,0.3); }
.player-name {
  font-size: clamp(10px, 2.2vw, 12px);
  font-weight: 700;
  color: #8899bb;
  white-space: nowrap;
  letter-spacing: 2px;
  text-transform: uppercase;
}
.turn-badge {
  display: inline-block;
  font-size: 8px;
  font-weight: 700;
  padding: 2px 6px;
  border-radius: 3px;
  margin-left: 4px;
  opacity: 0;
  transition: opacity 0.3s;
  letter-spacing: 2px;
  flex-shrink: 0;
}
.player-panel.active .turn-badge { opacity: 1; }
.player-panel.p1 .turn-badge { background: rgba(255,0,0,0.2); color: #ff6666; border: 1px solid rgba(255,0,0,0.3); }
.player-panel.p2 .turn-badge { background: rgba(0,100,255,0.2); color: #66aaff; border: 1px solid rgba(0,100,255,0.3); }
.wall-indicators {
  display: flex;
  gap: 3px;
  align-items: center;
  flex-wrap: wrap;
  margin-left: auto;
}
.wall-pip {
  width: 10px; height: 3px;
  border-radius: 1px;
  transition: all 0.3s;
}
.player-panel.p1 .wall-pip { background: rgba(255,0,0,0.5); box-shadow: 0 0 4px rgba(255,0,0,0.2); }
.player-panel.p2 .wall-pip { background: rgba(0,100,255,0.5); box-shadow: 0 0 4px rgba(0,100,255,0.2); }
.wall-pip.used { background: rgba(255,255,255,0.04) !important; box-shadow: none !important; }
.wall-label {
  font-size: 9px;
  color: #445;
  margin-left: 3px;
}

/* ---- Timer ---- */
.timer-area {
  display: flex;
  align-items: center;
  gap: 6px;
  margin-top: 3px;
}
.timer-bar-bg {
  flex: 1;
  height: 3px;
  border-radius: 1px;
  background: rgba(255,255,255,0.04);
  overflow: hidden;
}
.timer-bar-fill {
  height: 100%;
  border-radius: 1px;
  transition: width 0.25s linear, background 0.5s;
  width: 100%;
}
.player-panel.p1 .timer-bar-fill { background: linear-gradient(90deg, #cc0000, #ff4444); box-shadow: 0 0 6px rgba(255,0,0,0.3); }
.player-panel.p2 .timer-bar-fill { background: linear-gradient(90deg, #0044cc, #44aaff); box-shadow: 0 0 6px rgba(0,100,255,0.3); }
.timer-bar-fill.urgent { background: linear-gradient(90deg, #ff0000, #ff4444) !important; animation: pulse-urgent 0.5s ease-in-out infinite; }
@keyframes pulse-urgent { 0%,100% { opacity: 1; } 50% { opacity: 0.5; } }
.timer-text {
  font-size: 10px;
  font-weight: 700;
  font-variant-numeric: tabular-nums;
  min-width: 22px;
  text-align: right;
  color: #556;
  transition: color 0.3s;
  letter-spacing: 1px;
}
.timer-text.urgent { color: #ff2222; }
.player-panel:not(.active) .timer-area { opacity: 0.3; }

/* ---- Controls ---- */
.controls {
  display: flex;
  align-items: center;
  gap: 5px;
  justify-content: center;
  width: 100%;
}
.ctrl-btn {
  position: relative;
  padding: 8px 14px;
  border: 1px solid rgba(100,150,255,0.12);
  border-radius: 4px;
  background: rgba(10,20,40,0.6);
  color: #556688;
  font-family: 'Orbitron', inherit;
  font-size: 11px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.25s;
  letter-spacing: 1px;
  -webkit-tap-highlight-color: transparent;
  touch-action: manipulation;
  min-height: 40px;
  text-transform: uppercase;
}
.ctrl-btn:active { transform: scale(0.95); }
.ctrl-btn.active-move {
  border-color: rgba(0,255,100,0.4);
  color: #00ff66;
  background: rgba(0,255,100,0.06);
  box-shadow: 0 0 12px rgba(0,255,100,0.08);
}
.ctrl-btn.active-wall {
  border-color: rgba(255,200,0,0.4);
  color: #ffcc00;
  background: rgba(255,200,0,0.06);
  box-shadow: 0 0 12px rgba(255,200,0,0.08);
}
.ctrl-btn .kbd {
  display: inline-block;
  font-size: 8px;
  padding: 1px 4px;
  border-radius: 2px;
  background: rgba(255,255,255,0.05);
  color: #445;
  margin-left: 4px;
  font-weight: 400;
  vertical-align: 1px;
}
@media (hover: none) and (pointer: coarse) {
  .ctrl-btn .kbd { display: none; }
}
.ctrl-divider {
  width: 1px;
  height: 24px;
  background: rgba(100,150,255,0.08);
  margin: 0 1px;
}
.orient-group {
  display: flex;
  gap: 4px;
  opacity: 0;
  pointer-events: none;
  transition: opacity 0.25s;
}
.orient-group.visible {
  opacity: 1;
  pointer-events: auto;
}
.orient-btn {
  padding: 8px 12px;
  border: 1px solid rgba(100,150,255,0.08);
  border-radius: 4px;
  background: rgba(10,20,40,0.5);
  color: #445566;
  font-family: 'Orbitron', inherit;
  font-size: 11px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s;
  -webkit-tap-highlight-color: transparent;
  touch-action: manipulation;
  min-height: 40px;
}
.orient-btn:active { transform: scale(0.95); }
.orient-btn.active {
  border-color: rgba(255,200,0,0.3);
  color: #ffcc00;
  background: rgba(255,200,0,0.05);
}

/* Inactive player controls */
.controls.inactive {
  opacity: 0.25;
  pointer-events: none;
}

/* ---- Board ---- */
#board-container {
  position: relative;
  -webkit-user-select: none;
  user-select: none;
  touch-action: none;
  width: 100%;
  display: flex;
  justify-content: center;
  flex: 1;
  align-items: center;
  min-height: 0;
}
canvas#board {
  display: block;
  border-radius: 6px;
  cursor: pointer;
  box-shadow:
    0 4px 30px rgba(0,0,0,0.6),
    0 0 40px rgba(0, 50, 150, 0.06),
    inset 0 0 60px rgba(0, 50, 150, 0.02);
  max-width: 100%;
  max-height: 100%;
  touch-action: none;
}

/* ---- Center controls (reset/sound) ---- */
.center-controls {
  display: flex;
  gap: 8px;
  align-items: center;
  justify-content: center;
  flex-shrink: 0;
}
.sound-btn {
  width: 38px; height: 38px;
  border: 1px solid rgba(100,150,255,0.1);
  border-radius: 4px;
  background: rgba(10,20,40,0.6);
  color: #556688;
  font-size: 16px;
  cursor: pointer;
  transition: all 0.2s;
  display: flex;
  align-items: center;
  justify-content: center;
  -webkit-tap-highlight-color: transparent;
  touch-action: manipulation;
  position: relative;
}
.sound-btn:active { transform: scale(0.9); }
.sound-btn.muted { color: #ff2222; }
#reset-btn {
  padding: 8px 20px;
  border: 1px solid rgba(100,150,255,0.1);
  border-radius: 4px;
  background: rgba(10,20,40,0.6);
  color: #556688;
  font-family: 'Orbitron', inherit;
  font-size: 10px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.25s;
  -webkit-tap-highlight-color: transparent;
  touch-action: manipulation;
  min-height: 38px;
  letter-spacing: 2px;
  text-transform: uppercase;
}
#reset-btn:active { transform: scale(0.95); background: rgba(255,0,0,0.1); }

/* ---- Message ---- */
#message {
  font-size: 10px;
  min-height: 16px;
  text-align: center;
  color: #ff6644;
  font-weight: 600;
  letter-spacing: 1px;
  flex-shrink: 0;
}

/* ---- Winner Overlay ---- */
.winner-overlay {
  position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;
  background: rgba(0,0,0,0);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 100;
  pointer-events: none;
  transition: background 0.8s;
  overflow: hidden;
}
.winner-overlay.show {
  background: rgba(0,4,12,0.85);
  -webkit-backdrop-filter: blur(16px);
  backdrop-filter: blur(16px);
  pointer-events: auto;
}
.winner-box {
  background: linear-gradient(145deg, rgba(10,20,40,0.95), rgba(5,10,25,0.95));
  border-radius: 12px;
  padding: 40px 44px;
  text-align: center;
  border: 1px solid rgba(100,150,255,0.15);
  box-shadow: 0 20px 80px rgba(0,0,0,0.8), 0 0 60px rgba(0,80,200,0.1);
  transform: scale(0.5) rotate(-5deg);
  opacity: 0;
  transition: all 0.6s cubic-bezier(.2,.8,.3,1.2);
  margin: 16px;
  max-width: 340px;
  width: 90%;
}
.winner-overlay.show .winner-box {
  transform: scale(1) rotate(0deg);
  opacity: 1;
}
.winner-box .trophy {
  font-size: 64px;
  margin-bottom: 12px;
  animation: trophy-bounce 0.8s ease-out 0.5s both;
  filter: drop-shadow(0 0 20px rgba(255,200,0,0.4));
}
@keyframes trophy-bounce {
  0% { transform: scale(0) rotate(-30deg); }
  50% { transform: scale(1.3) rotate(5deg); }
  70% { transform: scale(0.9) rotate(-3deg); }
  100% { transform: scale(1) rotate(0deg); }
}
.winner-box h2 {
  font-size: clamp(24px, 6vw, 32px);
  font-weight: 900;
  margin-bottom: 6px;
  letter-spacing: 6px;
  text-transform: uppercase;
  font-family: 'Orbitron', sans-serif;
}
.winner-box h2.win-p1 {
  color: #ff4444;
  text-shadow: 0 0 20px rgba(255,0,0,0.5), 0 0 40px rgba(255,0,0,0.3);
  animation: saber-glow-red 1.5s ease-in-out infinite alternate;
}
.winner-box h2.win-p2 {
  color: #44aaff;
  text-shadow: 0 0 20px rgba(0,100,255,0.5), 0 0 40px rgba(0,100,255,0.3);
  animation: saber-glow-blue 1.5s ease-in-out infinite alternate;
}
@keyframes saber-glow-red {
  0% { text-shadow: 0 0 10px rgba(255,0,0,0.4); }
  100% { text-shadow: 0 0 30px rgba(255,0,0,0.6), 0 0 60px rgba(255,0,0,0.3); }
}
@keyframes saber-glow-blue {
  0% { text-shadow: 0 0 10px rgba(0,100,255,0.4); }
  100% { text-shadow: 0 0 30px rgba(0,100,255,0.6), 0 0 60px rgba(0,100,255,0.3); }
}
.winner-box .win-label {
  font-size: clamp(12px, 3vw, 16px);
  font-weight: 700;
  margin-bottom: 16px;
  letter-spacing: 3px;
}
.winner-box p { color: #445566; font-size: 12px; margin-bottom: 24px; letter-spacing: 1px; }
.winner-box button {
  padding: 16px 44px;
  border: 1px solid rgba(100,150,255,0.2);
  border-radius: 6px;
  background: linear-gradient(135deg, rgba(0,50,150,0.4), rgba(0,80,200,0.3));
  color: #88bbff;
  font-family: 'Orbitron', inherit;
  font-size: 13px;
  font-weight: 700;
  cursor: pointer;
  letter-spacing: 2px;
  -webkit-tap-highlight-color: transparent;
  touch-action: manipulation;
  min-height: 52px;
  transition: all 0.2s;
  text-transform: uppercase;
}
.winner-box button:hover { background: linear-gradient(135deg, rgba(0,60,180,0.5), rgba(0,100,255,0.4)); border-color: rgba(100,150,255,0.4); }
.winner-box button:active { transform: scale(0.93); }
.confetti {
  position: absolute;
  width: 10px; height: 10px;
  border-radius: 2px;
  animation: confetti-fall linear forwards;
  pointer-events: none;
}
@keyframes confetti-fall {
  0% { transform: translateY(-10px) rotate(0deg); opacity: 1; }
  100% { transform: translateY(110vh) rotate(720deg); opacity: 0; }
}

/* ---- Start Overlay ---- */
.start-overlay {
  position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;
  background: #000;
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 200;
  flex-direction: column;
}
.start-box {
  text-align: center;
  padding: 20px;
  animation: fadeInUp 1.5s ease-out;
}
@keyframes fadeInUp {
  0% { opacity: 0; transform: translateY(30px); }
  100% { opacity: 1; transform: translateY(0); }
}
.start-subtitle {
  font-size: clamp(10px, 2.5vw, 13px);
  color: #3366aa;
  letter-spacing: 4px;
  margin-bottom: 8px;
  font-weight: 400;
}
.start-box h2 {
  font-size: clamp(28px, 8vw, 44px);
  font-weight: 900;
  letter-spacing: clamp(6px, 2vw, 14px);
  color: #ffcc00;
  text-shadow: 0 0 30px rgba(255,200,0,0.3), 0 0 60px rgba(255,200,0,0.1);
  margin-bottom: 8px;
  font-family: 'Orbitron', sans-serif;
}
.start-box .tagline {
  color: #334466;
  font-size: clamp(10px, 2.5vw, 12px);
  margin-bottom: 40px;
  letter-spacing: 3px;
}
.start-box button {
  padding: 16px 48px;
  border: 1px solid rgba(255,200,0,0.3);
  border-radius: 6px;
  background: linear-gradient(135deg, rgba(255,200,0,0.15), rgba(255,150,0,0.1));
  color: #ffcc00;
  font-family: 'Orbitron', inherit;
  font-size: 14px;
  font-weight: 700;
  cursor: pointer;
  letter-spacing: 3px;
  -webkit-tap-highlight-color: transparent;
  touch-action: manipulation;
  min-height: 52px;
  text-transform: uppercase;
  transition: all 0.3s;
  box-shadow: 0 0 20px rgba(255,200,0,0.08);
}
.start-box button:hover {
  background: linear-gradient(135deg, rgba(255,200,0,0.25), rgba(255,150,0,0.15));
  box-shadow: 0 0 30px rgba(255,200,0,0.15);
}
.start-box button:active { transform: scale(0.95); }

.hidden { display: none; }
</style>
</head>
<body>

<!-- Start screen -->
<div class="start-overlay" id="start-overlay">
  <div class="start-box">
    <div class="start-subtitle">A GALACTIC STRATEGY GAME</div>
    <h2>QUORIDOR</h2>
    <p class="tagline">2 PLAYER DUEL</p>
    <button onclick="startGame()">START</button>
  </div>
</div>

<div id="app">
  <!-- P2 zone (top, rotated 180deg for face-to-face play) -->
  <div class="player-zone p2-zone">
    <div class="controls inactive" id="controls-p2">
      <button class="ctrl-btn active-move" id="btn-move-p2" onclick="setMode('move')">
        MOVE<span class="kbd">M</span>
      </button>
      <button class="ctrl-btn" id="btn-wall-p2" onclick="setMode('wall')">
        WALL<span class="kbd">W</span>
      </button>
      <div class="ctrl-divider"></div>
      <div class="orient-group" id="orient-group-p2">
        <button class="orient-btn active" id="btn-h-p2" onclick="setOrientation('h')">H</button>
        <button class="orient-btn" id="btn-v-p2" onclick="setOrientation('v')">V</button>
      </div>
    </div>
    <div class="player-panel p2" id="p2-panel">
      <div class="panel-row">
        <div class="player-icon p2">II</div>
        <span class="player-name">JEDI</span>
        <span class="turn-badge">TURN</span>
        <div class="wall-indicators" id="p2-walls"></div>
      </div>
      <div class="timer-area">
        <div class="timer-bar-bg"><div class="timer-bar-fill" id="p2-timer-bar"></div></div>
        <span class="timer-text" id="p2-timer-text">30</span>
      </div>
    </div>
  </div>

  <!-- Board -->
  <div id="board-container">
    <canvas id="board"></canvas>
  </div>

  <div id="message"></div>

  <!-- Center controls -->
  <div class="center-controls">
    <button class="sound-btn" id="sound-btn" onclick="toggleSound()" title="BGM ON/OFF">&#9835;</button>
    <button id="reset-btn" onclick="resetGame()">RESET</button>
  </div>

  <!-- P1 zone (bottom, normal orientation) -->
  <div class="player-zone p1-zone">
    <div class="player-panel p1 active" id="p1-panel">
      <div class="panel-row">
        <div class="player-icon p1">I</div>
        <span class="player-name">SITH</span>
        <span class="turn-badge">TURN</span>
        <div class="wall-indicators" id="p1-walls"></div>
      </div>
      <div class="timer-area">
        <div class="timer-bar-bg"><div class="timer-bar-fill" id="p1-timer-bar"></div></div>
        <span class="timer-text" id="p1-timer-text">30</span>
      </div>
    </div>
    <div class="controls" id="controls-p1">
      <button class="ctrl-btn active-move" id="btn-move-p1" onclick="setMode('move')">
        MOVE<span class="kbd">M</span>
      </button>
      <button class="ctrl-btn" id="btn-wall-p1" onclick="setMode('wall')">
        WALL<span class="kbd">W</span>
      </button>
      <div class="ctrl-divider"></div>
      <div class="orient-group" id="orient-group-p1">
        <button class="orient-btn active" id="btn-h-p1" onclick="setOrientation('h')">H</button>
        <button class="orient-btn" id="btn-v-p1" onclick="setOrientation('v')">V</button>
      </div>
    </div>
  </div>
</div>

<div class="winner-overlay" id="winner-overlay">
  <div class="winner-box">
    <div class="trophy">&#9876;</div>
    <h2 id="winner-text">VICTORY</h2>
    <div class="win-label" id="winner-player"></div>
    <p>THE FORCE IS STRONG WITH YOU</p>
    <button onclick="resetGame()">REMATCH</button>
  </div>
</div>

<script>
// ============ roundRect polyfill for older Safari ============
(function() {
  if (typeof CanvasRenderingContext2D !== 'undefined' &&
      !CanvasRenderingContext2D.prototype.roundRect) {
    CanvasRenderingContext2D.prototype.roundRect = function(x, y, w, h, radii) {
      let r = typeof radii === 'number' ? radii : (Array.isArray(radii) ? radii[0] : 0);
      if (r > w / 2) r = w / 2;
      if (r > h / 2) r = h / 2;
      this.moveTo(x + r, y);
      this.lineTo(x + w - r, y);
      this.quadraticCurveTo(x + w, y, x + w, y + r);
      this.lineTo(x + w, y + h - r);
      this.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
      this.lineTo(x + r, y + h);
      this.quadraticCurveTo(x, y + h, x, y + h - r);
      this.lineTo(x, y + r);
      this.quadraticCurveTo(x, y, x + r, y);
      this.closePath();
      return this;
    };
  }
})();

// ============ CONSTANTS ============
const GRID = 9;
const TURN_TIME = 30;

function calcBoardSize() {
  const vw = window.innerWidth;
  const vh = window.innerHeight;
  const maxBoard = Math.min(vw - 16, vh * 0.42, 520);
  const cellAndGap = maxBoard / (GRID + (GRID - 1) * 0.16 + 0.6);
  const cell = Math.floor(cellAndGap);
  const gap = Math.max(4, Math.round(cell * 0.16));
  const pad = Math.max(8, Math.round(cell * 0.3));
  return { cell, gap, pad };
}

let CELL, GAP, PAD, BOARD_PX, DPR;
const canvas = document.getElementById('board');
const ctx = canvas.getContext('2d');

function resizeBoard() {
  const s = calcBoardSize();
  CELL = s.cell;
  GAP = s.gap;
  PAD = s.pad;
  BOARD_PX = PAD * 2 + GRID * CELL + (GRID - 1) * GAP;
  DPR = window.devicePixelRatio || 1;
  canvas.style.width = BOARD_PX + 'px';
  canvas.style.height = BOARD_PX + 'px';
  canvas.width = Math.round(BOARD_PX * DPR);
  canvas.height = Math.round(BOARD_PX * DPR);
  ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
  draw();
}

// ============ AUDIO ENGINE (Web Audio API) ============
let audioCtx = null;
let bgmPlaying = false;
let bgmMuted = false;
let bgmGain = null;
let bgmTimeout = null;

function initAudio() {
  try {
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    if (audioCtx.state === 'suspended') audioCtx.resume();
    bgmGain = audioCtx.createGain();
    bgmGain.gain.value = 0.18;
    bgmGain.connect(audioCtx.destination);
  } catch (e) {
    console.warn('AudioContext not available', e);
    audioCtx = null;
  }
}

function ensureAudioResumed() {
  if (audioCtx && audioCtx.state === 'suspended') {
    audioCtx.resume();
  }
}

function playNote(freq, startTime, duration, gain, dest, type) {
  if (!audioCtx) return;
  const osc = audioCtx.createOscillator();
  const env = audioCtx.createGain();
  osc.type = type || 'sine';
  osc.frequency.value = freq;
  env.gain.setValueAtTime(0, startTime);
  env.gain.linearRampToValueAtTime(gain, startTime + 0.04);
  env.gain.exponentialRampToValueAtTime(0.001, startTime + duration - 0.02);
  env.gain.setValueAtTime(0, startTime + duration);
  osc.connect(env);
  env.connect(dest);
  osc.start(startTime);
  osc.stop(startTime + duration);
}

// Imperial-style dark, cinematic melody
const BGM_MELODY = [
  { n: 'G3', d: 0.75 }, { n: 'G3', d: 0.75 }, { n: 'G3', d: 0.75 },
  { n: 'Eb3', d: 0.5 }, { n: 'Bb3', d: 0.25 },
  { n: 'G3', d: 0.75 }, { n: 'Eb3', d: 0.5 }, { n: 'Bb3', d: 0.25 },
  { n: 'G3', d: 1.5 },
  { n: 'D4', d: 0.75 }, { n: 'D4', d: 0.75 }, { n: 'D4', d: 0.75 },
  { n: 'Eb4', d: 0.5 }, { n: 'Bb3', d: 0.25 },
  { n: 'F#3', d: 0.75 }, { n: 'Eb3', d: 0.5 }, { n: 'Bb3', d: 0.25 },
  { n: 'G3', d: 1.5 },
];

const BGM_BASS = [
  { n: 'G2', d: 3 }, { n: 'Eb2', d: 1.5 }, { n: 'G2', d: 1.5 },
  { n: 'G2', d: 3 },
  { n: 'D3', d: 3 }, { n: 'Eb3', d: 1.5 }, { n: 'Bb2', d: 1.5 },
  { n: 'G2', d: 3 },
];

const NF = {
  'C2': 65.41, 'D2': 73.42, 'Eb2': 77.78, 'E2': 82.41, 'F2': 87.31, 'F#2': 92.50, 'G2': 98.00, 'A2': 110.0, 'Bb2': 116.54, 'B2': 123.5,
  'C3': 130.8, 'D3': 146.8, 'Eb3': 155.56, 'E3': 164.8, 'F3': 174.6, 'F#3': 185.0, 'G3': 196.0, 'A3': 220.0, 'Bb3': 233.08, 'B3': 246.9,
  'C4': 261.6, 'D4': 293.7, 'Eb4': 311.13, 'E4': 329.6, 'F4': 349.2, 'F#4': 370.0, 'G4': 392.0, 'A4': 440.0, 'Bb4': 466.16, 'B4': 493.9,
  'C5': 523.3, 'D5': 587.3, 'Eb5': 622.25, 'E5': 659.3, 'F5': 698.5, 'G5': 784.0, 'A5': 880.0, 'B5': 987.8,
};

function scheduleBGMLoop() {
  if (!audioCtx || bgmMuted) return;
  const tempo = 0.45;
  const now = audioCtx.currentTime + 0.1;
  let t = now;
  for (const note of BGM_MELODY) {
    const dur = note.d * tempo;
    playNote(NF[note.n], t, dur * 0.9, 0.10, bgmGain, 'sawtooth');
    playNote(NF[note.n] * 2, t, dur * 0.6, 0.02, bgmGain, 'sine');
    t += dur;
  }
  const melodyLen = t - now;
  let tb = now;
  for (const note of BGM_BASS) {
    const dur = note.d * tempo;
    if (tb < now + melodyLen) playNote(NF[note.n], tb, dur * 0.85, 0.08, bgmGain, 'sine');
    tb += dur;
  }
  bgmTimeout = setTimeout(() => {
    if (bgmPlaying && !bgmMuted) scheduleBGMLoop();
  }, melodyLen * 1000 - 100);
}

function startBGM() {
  if (!audioCtx) return;
  bgmPlaying = true;
  bgmMuted = false;
  bgmGain.gain.value = 0.18;
  scheduleBGMLoop();
  updateSoundBtn();
}

function stopBGM() {
  bgmPlaying = false;
  if (bgmTimeout) clearTimeout(bgmTimeout);
  updateSoundBtn();
}

function toggleSound() {
  if (!audioCtx) return;
  ensureAudioResumed();
  bgmMuted = !bgmMuted;
  if (bgmMuted) {
    bgmGain.gain.value = 0;
    if (bgmTimeout) clearTimeout(bgmTimeout);
  } else {
    bgmGain.gain.value = 0.18;
    if (bgmPlaying) scheduleBGMLoop();
  }
  updateSoundBtn();
}

function updateSoundBtn() {
  const btn = document.getElementById('sound-btn');
  btn.classList.toggle('muted', bgmMuted);
  btn.innerHTML = bgmMuted ? '&#9834;<span style="font-size:10px;position:absolute;color:#ff2222">&#10005;</span>' : '&#9835;';
}

// --- Sound Effects ---
function createNoiseBuffer(duration) {
  if (!audioCtx) return null;
  const len = audioCtx.sampleRate * duration;
  const buf = audioCtx.createBuffer(1, len, audioCtx.sampleRate);
  const data = buf.getChannelData(0);
  for (let i = 0; i < len; i++) data[i] = Math.random() * 2 - 1;
  return buf;
}

function playMoveSFX() {
  if (!audioCtx) return;
  ensureAudioResumed();
  const now = audioCtx.currentTime;
  // Lightsaber-like hum
  const osc = audioCtx.createOscillator();
  osc.type = 'sawtooth';
  osc.frequency.setValueAtTime(180, now);
  osc.frequency.exponentialRampToValueAtTime(120, now + 0.15);
  const env = audioCtx.createGain();
  env.gain.setValueAtTime(0.15, now);
  env.gain.exponentialRampToValueAtTime(0.001, now + 0.15);
  osc.connect(env); env.connect(audioCtx.destination);
  osc.start(now); osc.stop(now + 0.15);

  const osc2 = audioCtx.createOscillator();
  osc2.type = 'sine';
  osc2.frequency.setValueAtTime(600, now);
  osc2.frequency.exponentialRampToValueAtTime(300, now + 0.1);
  const env2 = audioCtx.createGain();
  env2.gain.setValueAtTime(0.08, now);
  env2.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
  osc2.connect(env2); env2.connect(audioCtx.destination);
  osc2.start(now); osc2.stop(now + 0.1);
}

function playWallSFX() {
  if (!audioCtx) return;
  ensureAudioResumed();
  const now = audioCtx.currentTime;
  // Force push effect
  const noiseSrc = audioCtx.createBufferSource();
  noiseSrc.buffer = createNoiseBuffer(0.3);
  const lp = audioCtx.createBiquadFilter();
  lp.type = 'lowpass';
  lp.frequency.setValueAtTime(3000, now);
  lp.frequency.exponentialRampToValueAtTime(200, now + 0.2);
  const noiseEnv = audioCtx.createGain();
  noiseEnv.gain.setValueAtTime(0.35, now);
  noiseEnv.gain.exponentialRampToValueAtTime(0.001, now + 0.25);
  noiseSrc.connect(lp); lp.connect(noiseEnv); noiseEnv.connect(audioCtx.destination);
  noiseSrc.start(now); noiseSrc.stop(now + 0.3);

  const osc = audioCtx.createOscillator();
  osc.type = 'sine';
  osc.frequency.setValueAtTime(150, now);
  osc.frequency.exponentialRampToValueAtTime(60, now + 0.2);
  const oscEnv = audioCtx.createGain();
  oscEnv.gain.setValueAtTime(0.2, now);
  oscEnv.gain.exponentialRampToValueAtTime(0.001, now + 0.2);
  osc.connect(oscEnv); oscEnv.connect(audioCtx.destination);
  osc.start(now); osc.stop(now + 0.2);
}

function playTimerWarnSFX() {
  if (!audioCtx) return;
  const now = audioCtx.currentTime;
  const osc = audioCtx.createOscillator();
  const env = audioCtx.createGain();
  osc.type = 'square'; osc.frequency.value = 440;
  env.gain.setValueAtTime(0.08, now);
  env.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
  osc.connect(env); env.connect(audioCtx.destination);
  osc.start(now); osc.stop(now + 0.1);
}

function playTimeoutSFX() {
  if (!audioCtx) return;
  const now = audioCtx.currentTime;
  for (let i = 0; i < 3; i++) {
    const osc = audioCtx.createOscillator();
    const env = audioCtx.createGain();
    osc.type = 'sawtooth'; osc.frequency.value = 300 - i * 80;
    env.gain.setValueAtTime(0.12, now + i * 0.15);
    env.gain.exponentialRampToValueAtTime(0.001, now + i * 0.15 + 0.14);
    osc.connect(env); env.connect(audioCtx.destination);
    osc.start(now + i * 0.15); osc.stop(now + i * 0.15 + 0.15);
  }
}

function playWinSFX() {
  if (!audioCtx) return;
  const now = audioCtx.currentTime;
  // Triumphant fanfare
  [196.0, 261.6, 329.6, 392.0, 523.3].forEach((freq, i) => {
    const osc = audioCtx.createOscillator();
    const env = audioCtx.createGain();
    osc.type = 'sawtooth'; osc.frequency.value = freq;
    const t = now + i * 0.18;
    env.gain.setValueAtTime(0, t);
    env.gain.linearRampToValueAtTime(0.15, t + 0.05);
    env.gain.exponentialRampToValueAtTime(0.01, t + 0.6);
    osc.connect(env); env.connect(audioCtx.destination);
    osc.start(t); osc.stop(t + 0.6);
    const osc2 = audioCtx.createOscillator();
    const env2 = audioCtx.createGain();
    osc2.type = 'sine'; osc2.frequency.value = freq * 2;
    env2.gain.setValueAtTime(0, t);
    env2.gain.linearRampToValueAtTime(0.05, t + 0.05);
    env2.gain.exponentialRampToValueAtTime(0.001, t + 0.5);
    osc2.connect(env2); env2.connect(audioCtx.destination);
    osc2.start(t); osc2.stop(t + 0.5);
  });
}

// ============ STATE ============
let players, walls, wallCounts, currentPlayer, mode, orientation, gameOver, hoverWall;
let turnTimeLeft, timerInterval, gameStarted;

function initState() {
  players = [{ row: 8, col: 4 }, { row: 0, col: 4 }];
  walls = [];
  wallCounts = [10, 10];
  currentPlayer = 0;
  mode = 'move';
  orientation = 'h';
  gameOver = false;
  hoverWall = null;
  turnTimeLeft = TURN_TIME;
  gameStarted = false;
}

// ============ TIMER ============
function startTurnTimer() {
  turnTimeLeft = TURN_TIME;
  clearInterval(timerInterval);
  let lastWarnAt = -1;
  timerInterval = setInterval(() => {
    if (gameOver) { clearInterval(timerInterval); return; }
    turnTimeLeft -= 0.25;
    if (turnTimeLeft <= 0) {
      turnTimeLeft = 0;
      clearInterval(timerInterval);
      onTimeout();
    }
    const sec = Math.ceil(turnTimeLeft);
    if (sec <= 5 && sec !== lastWarnAt && turnTimeLeft > 0) {
      lastWarnAt = sec;
      playTimerWarnSFX();
    }
    updateTimerUI();
  }, 250);
}

function onTimeout() {
  playTimeoutSFX();
  showMsg('TIME OUT - TURN SKIPPED');
  currentPlayer = 1 - currentPlayer;
  mode = 'move';
  hoverWall = null;
  updateUI();
  draw();
  startTurnTimer();
}

function updateTimerUI() {
  const sec = Math.ceil(turnTimeLeft);
  const pct = (turnTimeLeft / TURN_TIME) * 100;
  const urgent = turnTimeLeft <= 5;
  for (let p = 0; p < 2; p++) {
    const bar = document.getElementById('p' + (p+1) + '-timer-bar');
    const txt = document.getElementById('p' + (p+1) + '-timer-text');
    if (p === currentPlayer) {
      bar.style.width = pct + '%';
      bar.classList.toggle('urgent', urgent);
      txt.textContent = sec;
      txt.classList.toggle('urgent', urgent);
    } else {
      bar.style.width = '100%';
      bar.classList.remove('urgent');
      txt.textContent = '30';
      txt.classList.remove('urgent');
    }
  }
}

// ============ COORDINATE HELPERS ============
function cellX(col) { return PAD + col * (CELL + GAP); }
function cellY(row) { return PAD + row * (CELL + GAP); }

function pixelToCell(px, py) {
  for (let r = 0; r < GRID; r++) {
    for (let c = 0; c < GRID; c++) {
      const x = cellX(c), y = cellY(r);
      if (px >= x && px < x + CELL && py >= y && py < y + CELL) return { row: r, col: c };
    }
  }
  return null;
}

function pixelToWallSlot(px, py) {
  const dist = Math.max(CELL * 0.55, 24);
  for (let r = 0; r < GRID - 1; r++) {
    for (let c = 0; c < GRID - 1; c++) {
      const cx = cellX(c) + CELL + GAP / 2;
      const cy = cellY(r) + CELL + GAP / 2;
      if (Math.abs(px - cx) < dist && Math.abs(py - cy) < dist) return { row: r, col: c };
    }
  }
  return null;
}

// ============ WALL LOGIC ============
function isBlocked(r1, c1, r2, c2) {
  const dr = r2 - r1, dc = c2 - c1;
  for (const w of walls) {
    if (dr === -1 && dc === 0 && w.orient === 'h' && w.row === r1 - 1 && (w.col === c1 || w.col === c1 - 1)) return true;
    if (dr === 1  && dc === 0 && w.orient === 'h' && w.row === r1     && (w.col === c1 || w.col === c1 - 1)) return true;
    if (dc === -1 && dr === 0 && w.orient === 'v' && w.col === c1 - 1 && (w.row === r1 || w.row === r1 - 1)) return true;
    if (dc === 1  && dr === 0 && w.orient === 'v' && w.col === c1     && (w.row === r1 || w.row === r1 - 1)) return true;
  }
  return false;
}

function wallOverlaps(r, c, o) {
  for (const w of walls) {
    if (w.orient === o && o === 'h' && w.row === r && Math.abs(w.col - c) <= 1) return true;
    if (w.orient === o && o === 'v' && w.col === c && Math.abs(w.row - r) <= 1) return true;
    if (w.row === r && w.col === c && w.orient !== o) return true;
  }
  return false;
}

function canReachGoal(p, extraWalls) {
  const goalRow = p === 0 ? 0 : 8;
  const allWalls = walls.concat(extraWalls || []);
  const visited = Array.from({ length: GRID }, () => Array(GRID).fill(false));
  const queue = [{ row: players[p].row, col: players[p].col }];
  visited[players[p].row][players[p].col] = true;
  function blocked(r1, c1, r2, c2) {
    const dr = r2 - r1, dc = c2 - c1;
    for (const w of allWalls) {
      if (dr === -1 && dc === 0 && w.orient === 'h' && w.row === r1 - 1 && (w.col === c1 || w.col === c1 - 1)) return true;
      if (dr === 1  && dc === 0 && w.orient === 'h' && w.row === r1     && (w.col === c1 || w.col === c1 - 1)) return true;
      if (dc === -1 && dr === 0 && w.orient === 'v' && w.col === c1 - 1 && (w.row === r1 || w.row === r1 - 1)) return true;
      if (dc === 1  && dr === 0 && w.orient === 'v' && w.col === c1     && (w.row === r1 || w.row === r1 - 1)) return true;
    }
    return false;
  }
  while (queue.length) {
    const { row, col } = queue.shift();
    if (row === goalRow) return true;
    for (const [dr, dc] of [[-1,0],[1,0],[0,-1],[0,1]]) {
      const nr = row + dr, nc = col + dc;
      if (nr < 0 || nr >= GRID || nc < 0 || nc >= GRID) continue;
      if (visited[nr][nc]) continue;
      if (blocked(row, col, nr, nc)) continue;
      visited[nr][nc] = true;
      queue.push({ row: nr, col: nc });
    }
  }
  return false;
}

function canPlaceWall(r, c, o) {
  if (r < 0 || r >= GRID - 1 || c < 0 || c >= GRID - 1) return false;
  if (wallOverlaps(r, c, o)) return false;
  const tw = { row: r, col: c, orient: o };
  return canReachGoal(0, [tw]) && canReachGoal(1, [tw]);
}

// ============ MOVEMENT LOGIC ============
function getValidMoves(p) {
  const { row, col } = players[p];
  const opp = players[1 - p];
  const moves = [];
  for (const [dr, dc] of [[-1,0],[1,0],[0,-1],[0,1]]) {
    const nr = row + dr, nc = col + dc;
    if (nr < 0 || nr >= GRID || nc < 0 || nc >= GRID) continue;
    if (isBlocked(row, col, nr, nc)) continue;
    if (opp.row === nr && opp.col === nc) {
      const jr = nr + dr, jc = nc + dc;
      if (jr >= 0 && jr < GRID && jc >= 0 && jc < GRID && !isBlocked(nr, nc, jr, jc)) {
        moves.push({ row: jr, col: jc });
      } else {
        for (const [dr2, dc2] of [[-1,0],[1,0],[0,-1],[0,1]]) {
          if (dr2 === -dr && dc2 === -dc) continue;
          const djr = nr + dr2, djc = nc + dc2;
          if (djr < 0 || djr >= GRID || djc < 0 || djc >= GRID) continue;
          if (isBlocked(nr, nc, djr, djc)) continue;
          moves.push({ row: djr, col: djc });
        }
      }
    } else {
      moves.push({ row: nr, col: nc });
    }
  }
  return moves;
}

// ============ DRAWING ============
function draw() {
  ctx.clearRect(0, 0, BOARD_PX, BOARD_PX);

  // Dark metallic background
  const bg = ctx.createLinearGradient(0, 0, BOARD_PX, BOARD_PX);
  bg.addColorStop(0, '#080c18');
  bg.addColorStop(0.5, '#0a1020');
  bg.addColorStop(1, '#060a14');
  ctx.fillStyle = bg;
  ctx.beginPath();
  ctx.roundRect(0, 0, BOARD_PX, BOARD_PX, 8);
  ctx.fill();

  // Grid border
  ctx.strokeStyle = 'rgba(60,100,180,0.12)';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.roundRect(0.5, 0.5, BOARD_PX - 1, BOARD_PX - 1, 8);
  ctx.stroke();

  // Cells - metallic grid panels
  const cr = Math.max(2, CELL * 0.08);
  for (let r = 0; r < GRID; r++) {
    for (let c = 0; c < GRID; c++) {
      const x = cellX(c), y = cellY(r);
      // Subtle metallic panel
      ctx.fillStyle = 'rgba(30,50,80,0.25)';
      ctx.beginPath();
      ctx.roundRect(x, y, CELL, CELL, cr);
      ctx.fill();
      // Panel edge highlight
      ctx.strokeStyle = 'rgba(60,100,180,0.08)';
      ctx.lineWidth = 0.5;
      ctx.beginPath();
      ctx.roundRect(x, y, CELL, CELL, cr);
      ctx.stroke();
    }
  }

  // Goal rows - red glow for P1 (Sith side, row 0) and blue glow for P2 (Jedi side, row 8)
  for (let c = 0; c < GRID; c++) {
    const g1 = ctx.createLinearGradient(0, cellY(0), 0, cellY(0) + CELL);
    g1.addColorStop(0, 'rgba(255, 0, 0, 0.12)');
    g1.addColorStop(1, 'rgba(255, 0, 0, 0.03)');
    ctx.fillStyle = g1;
    ctx.beginPath(); ctx.roundRect(cellX(c), cellY(0), CELL, CELL, cr); ctx.fill();

    const g2 = ctx.createLinearGradient(0, cellY(8), 0, cellY(8) + CELL);
    g2.addColorStop(0, 'rgba(0, 100, 255, 0.03)');
    g2.addColorStop(1, 'rgba(0, 100, 255, 0.12)');
    ctx.fillStyle = g2;
    ctx.beginPath(); ctx.roundRect(cellX(c), cellY(8), CELL, CELL, cr); ctx.fill();
  }

  // Valid moves - holographic green indicators
  if (!gameOver && mode === 'move') {
    const moves = getValidMoves(currentPlayer);
    for (const m of moves) {
      const x = cellX(m.col), y = cellY(m.row);
      ctx.fillStyle = 'rgba(0, 255, 100, 0.08)';
      ctx.beginPath(); ctx.roundRect(x, y, CELL, CELL, cr); ctx.fill();
      ctx.strokeStyle = 'rgba(0, 255, 100, 0.35)';
      ctx.lineWidth = 1.5;
      ctx.setLineDash([3, 3]);
      ctx.beginPath(); ctx.roundRect(x + 1, y + 1, CELL - 2, CELL - 2, cr); ctx.stroke();
      ctx.setLineDash([]);
      // Holographic dot
      ctx.fillStyle = 'rgba(0, 255, 100, 0.4)';
      ctx.beginPath(); ctx.arc(x + CELL / 2, y + CELL / 2, Math.max(2, CELL * 0.06), 0, Math.PI * 2); ctx.fill();
    }
  }

  // Walls - energy barriers
  for (const w of walls) drawWall(w.row, w.col, w.orient);
  if (hoverWall && !gameOver) {
    drawWallPreview(hoverWall.row, hoverWall.col, hoverWall.orient, canPlaceWall(hoverWall.row, hoverWall.col, hoverWall.orient));
  }

  // Players - lightsaber-powered orbs
  drawPlayer(players[0], 0);
  drawPlayer(players[1], 1);
}

function drawWall(r, c, orient) {
  ctx.save();
  const wr = Math.max(2, GAP * 0.3);
  if (orient === 'h') {
    const x = cellX(c), y = cellY(r) + CELL, w = CELL * 2 + GAP, h = GAP;
    const grad = ctx.createLinearGradient(x, y, x + w, y);
    grad.addColorStop(0, 'rgba(255,200,0,0.3)');
    grad.addColorStop(0.5, 'rgba(255,220,50,0.8)');
    grad.addColorStop(1, 'rgba(255,200,0,0.3)');
    ctx.fillStyle = grad;
    ctx.shadowColor = 'rgba(255, 200, 0, 0.5)';
    ctx.shadowBlur = 12;
    ctx.beginPath(); ctx.roundRect(x, y, w, h, wr); ctx.fill();
    // Core glow
    ctx.shadowBlur = 0;
    ctx.fillStyle = 'rgba(255,255,200,0.4)';
    ctx.beginPath(); ctx.roundRect(x + w*0.1, y + h*0.25, w*0.8, h*0.5, 1); ctx.fill();
  } else {
    const x = cellX(c) + CELL, y = cellY(r), w = GAP, h = CELL * 2 + GAP;
    const grad = ctx.createLinearGradient(x, y, x, y + h);
    grad.addColorStop(0, 'rgba(255,200,0,0.3)');
    grad.addColorStop(0.5, 'rgba(255,220,50,0.8)');
    grad.addColorStop(1, 'rgba(255,200,0,0.3)');
    ctx.fillStyle = grad;
    ctx.shadowColor = 'rgba(255, 200, 0, 0.5)';
    ctx.shadowBlur = 12;
    ctx.beginPath(); ctx.roundRect(x, y, w, h, wr); ctx.fill();
    ctx.shadowBlur = 0;
    ctx.fillStyle = 'rgba(255,255,200,0.4)';
    ctx.beginPath(); ctx.roundRect(x + w*0.25, y + h*0.1, w*0.5, h*0.8, 1); ctx.fill();
  }
  ctx.restore();
}

function drawWallPreview(r, c, orient, valid) {
  ctx.save();
  ctx.globalAlpha = 0.6;
  const color = valid ? 'rgba(0, 255, 100, 0.7)' : 'rgba(255, 0, 0, 0.7)';
  ctx.fillStyle = color; ctx.shadowColor = color; ctx.shadowBlur = 14;
  const wr = Math.max(2, GAP * 0.3);
  if (orient === 'h') {
    ctx.beginPath(); ctx.roundRect(cellX(c), cellY(r) + CELL, CELL * 2 + GAP, GAP, wr); ctx.fill();
  } else {
    ctx.beginPath(); ctx.roundRect(cellX(c) + CELL, cellY(r), GAP, CELL * 2 + GAP, wr); ctx.fill();
  }
  ctx.restore();
}

function drawPlayer(p, idx) {
  const cx = cellX(p.col) + CELL / 2;
  const cy = cellY(p.row) + CELL / 2;
  const isActive = currentPlayer === idx && !gameOver;
  const pr = CELL * 0.34;

  // Sith (red) vs Jedi (blue)
  const colors = idx === 0
    ? { core: '#ff2222', light: '#ff6666', glow: 'rgba(255,0,0,', saber: '#ff0000' }
    : { core: '#2288ff', light: '#66bbff', glow: 'rgba(0,100,255,', saber: '#0066ff' };

  ctx.save();

  // Outer force aura
  if (isActive) {
    const gg = ctx.createRadialGradient(cx, cy, pr * 0.3, cx, cy, pr * 2.2);
    gg.addColorStop(0, colors.glow + '0.2)');
    gg.addColorStop(0.5, colors.glow + '0.05)');
    gg.addColorStop(1, colors.glow + '0)');
    ctx.fillStyle = gg;
    ctx.beginPath(); ctx.arc(cx, cy, pr * 2.2, 0, Math.PI * 2); ctx.fill();
  }

  // Lightsaber glow
  ctx.shadowColor = colors.saber;
  ctx.shadowBlur = isActive ? pr * 1.2 : pr * 0.5;

  // Main orb
  const grad = ctx.createRadialGradient(cx - pr * 0.2, cy - pr * 0.2, pr * 0.05, cx, cy, pr);
  grad.addColorStop(0, '#ffffff');
  grad.addColorStop(0.3, colors.light);
  grad.addColorStop(1, colors.core);
  ctx.fillStyle = grad;
  ctx.beginPath(); ctx.arc(cx, cy, pr, 0, Math.PI * 2); ctx.fill();

  // Inner white core
  ctx.shadowColor = 'transparent';
  ctx.fillStyle = 'rgba(255,255,255,0.3)';
  ctx.beginPath(); ctx.arc(cx - pr * 0.2, cy - pr * 0.2, pr * 0.35, 0, Math.PI * 2); ctx.fill();

  // Edge ring
  ctx.strokeStyle = 'rgba(255,255,255,0.15)';
  ctx.lineWidth = 1;
  ctx.beginPath(); ctx.arc(cx, cy, pr, 0, Math.PI * 2); ctx.stroke();

  ctx.restore();
}

// ============ UI ============
function renderWallPips(containerId, count) {
  const el = document.getElementById(containerId);
  let html = '';
  for (let i = 0; i < 10; i++) html += '<div class="wall-pip' + (i >= count ? ' used' : '') + '"></div>';
  html += '<span class="wall-label">' + count + '</span>';
  el.innerHTML = html;
}

function updateUI() {
  document.getElementById('p1-panel').classList.toggle('active', currentPlayer === 0);
  document.getElementById('p2-panel').classList.toggle('active', currentPlayer === 1);
  renderWallPips('p1-walls', wallCounts[0]);
  renderWallPips('p2-walls', wallCounts[1]);

  // Update both sets of controls
  for (var pIdx = 0; pIdx < 2; pIdx++) {
    var suffix = pIdx === 0 ? '-p1' : '-p2';
    var controlsEl = document.getElementById('controls' + suffix);
    controlsEl.classList.toggle('inactive', currentPlayer !== pIdx);

    document.getElementById('btn-move' + suffix).className = 'ctrl-btn' + (mode === 'move' ? ' active-move' : '');
    document.getElementById('btn-wall' + suffix).className = 'ctrl-btn' + (mode === 'wall' ? ' active-wall' : '');
    document.getElementById('orient-group' + suffix).classList.toggle('visible', mode === 'wall');
    document.getElementById('btn-h' + suffix).classList.toggle('active', orientation === 'h');
    document.getElementById('btn-v' + suffix).classList.toggle('active', orientation === 'v');
  }

  updateTimerUI();
}

function setMode(m) {
  if (gameOver) return;
  mode = m;
  hoverWall = null;
  showMsg('');
  updateUI();
  draw();
}

function setOrientation(o) {
  orientation = o;
  hoverWall = null;
  updateUI();
  draw();
}

function showMsg(text) {
  document.getElementById('message').textContent = text;
}

function showWinner(p) {
  gameOver = true;
  clearInterval(timerInterval);
  stopBGM();
  playWinSFX();
  var overlay = document.getElementById('winner-overlay');
  var text = document.getElementById('winner-text');
  var playerLabel = document.getElementById('winner-player');
  text.className = p === 0 ? 'win-p1' : 'win-p2';
  text.textContent = 'VICTORY';
  playerLabel.className = 'win-label';
  playerLabel.textContent = p === 0 ? 'DARK SIDE' : 'LIGHT SIDE';
  playerLabel.style.color = p === 0 ? '#ff6666' : '#66aaff';
  requestAnimationFrame(function() {
    overlay.classList.add('show');
    spawnConfetti(overlay);
  });
}

function spawnConfetti(container) {
  var colors = ['#ff0000','#ff4444','#0066ff','#44aaff','#ffcc00','#ffffff','#ff6600','#00ff88'];
  var existing = container.querySelectorAll('.confetti');
  for (var i = 0; i < existing.length; i++) existing[i].remove();
  for (var i = 0; i < 60; i++) {
    var el = document.createElement('div');
    el.className = 'confetti';
    el.style.left = Math.random() * 100 + '%';
    el.style.top = '-10px';
    el.style.background = colors[Math.floor(Math.random() * colors.length)];
    el.style.width = (Math.random() * 8 + 5) + 'px';
    el.style.height = (Math.random() * 8 + 5) + 'px';
    el.style.animationDuration = (Math.random() * 2 + 2) + 's';
    el.style.animationDelay = (Math.random() * 1.5) + 's';
    container.appendChild(el);
  }
}

function startGame() {
  document.getElementById('start-overlay').classList.add('hidden');
  initAudio();
  initState();
  gameStarted = true;
  resizeBoard();
  showMsg('');
  updateUI();
  draw();
  startBGM();
  startTurnTimer();
}

function resetGame() {
  var overlay = document.getElementById('winner-overlay');
  overlay.classList.remove('show');
  var confetti = overlay.querySelectorAll('.confetti');
  for (var i = 0; i < confetti.length; i++) confetti[i].remove();
  clearInterval(timerInterval);
  if (bgmTimeout) clearTimeout(bgmTimeout);
  bgmPlaying = false;
  if (audioCtx) {
    audioCtx.close().catch(function(){});
    audioCtx = null;
  }
  initState();
  gameStarted = true;
  showMsg('');
  updateUI();
  draw();
  initAudio();
  startBGM();
  startTurnTimer();
}

// ============ TOUCH & POINTER HELPERS ============
function getCanvasPos(e) {
  const rect = canvas.getBoundingClientRect();
  const scaleX = BOARD_PX / rect.width;
  const scaleY = BOARD_PX / rect.height;
  let clientX, clientY;
  if (e.touches && e.touches.length > 0) {
    clientX = e.touches[0].clientX;
    clientY = e.touches[0].clientY;
  } else if (e.changedTouches && e.changedTouches.length > 0) {
    clientX = e.changedTouches[0].clientX;
    clientY = e.changedTouches[0].clientY;
  } else {
    clientX = e.clientX;
    clientY = e.clientY;
  }
  return {
    px: (clientX - rect.left) * scaleX,
    py: (clientY - rect.top) * scaleY
  };
}

function handleBoardAction(px, py) {
  if (gameOver || !gameStarted) return;
  ensureAudioResumed();

  if (mode === 'move') {
    const cell = pixelToCell(px, py);
    if (!cell) return;
    const moves = getValidMoves(currentPlayer);
    const match = moves.find(function(m) { return m.row === cell.row && m.col === cell.col; });
    if (!match) { showMsg('INVALID MOVE'); return; }
    players[currentPlayer].row = match.row;
    players[currentPlayer].col = match.col;
    playMoveSFX();
    showMsg('');
    if (currentPlayer === 0 && players[0].row === 0) { draw(); updateUI(); showWinner(0); return; }
    if (currentPlayer === 1 && players[1].row === 8) { draw(); updateUI(); showWinner(1); return; }
    currentPlayer = 1 - currentPlayer;
    updateUI(); draw(); startTurnTimer();
  } else {
    const slot = pixelToWallSlot(px, py);
    if (!slot) { showMsg('TAP NEAR AN INTERSECTION'); return; }
    if (wallCounts[currentPlayer] <= 0) { showMsg('NO WALLS REMAINING'); return; }
    if (!canPlaceWall(slot.row, slot.col, orientation)) { showMsg('CANNOT PLACE WALL HERE'); return; }
    walls.push({ row: slot.row, col: slot.col, orient: orientation });
    wallCounts[currentPlayer]--;
    playWallSFX();
    showMsg('');
    mode = 'move';
    hoverWall = null;
    currentPlayer = 1 - currentPlayer;
    updateUI(); draw(); startTurnTimer();
  }
}

// ============ EVENTS ============
// Mouse events (desktop)
canvas.addEventListener('click', function(e) {
  const pos = getCanvasPos(e);
  handleBoardAction(pos.px, pos.py);
});

canvas.addEventListener('mousemove', function(e) {
  if (gameOver || mode !== 'wall') {
    if (hoverWall) { hoverWall = null; draw(); }
    return;
  }
  const pos = getCanvasPos(e);
  const slot = pixelToWallSlot(pos.px, pos.py);
  hoverWall = slot ? { row: slot.row, col: slot.col, orient: orientation } : null;
  draw();
});

canvas.addEventListener('mouseleave', function() {
  hoverWall = null;
  draw();
});

// Touch events (mobile)
let touchStartPos = null;
canvas.addEventListener('touchstart', function(e) {
  e.preventDefault();
  touchStartPos = getCanvasPos(e);
}, { passive: false });

canvas.addEventListener('touchmove', function(e) {
  e.preventDefault();
  if (mode === 'wall' && !gameOver) {
    const pos = getCanvasPos(e);
    const slot = pixelToWallSlot(pos.px, pos.py);
    hoverWall = slot ? { row: slot.row, col: slot.col, orient: orientation } : null;
    draw();
  }
}, { passive: false });

canvas.addEventListener('touchend', function(e) {
  e.preventDefault();
  if (!touchStartPos) return;
  const endPos = getCanvasPos(e);
  const dx = endPos.px - touchStartPos.px;
  const dy = endPos.py - touchStartPos.py;
  if (Math.abs(dx) < CELL * 1.5 && Math.abs(dy) < CELL * 1.5) {
    handleBoardAction(endPos.px, endPos.py);
  }
  hoverWall = null;
  touchStartPos = null;
  draw();
}, { passive: false });

canvas.addEventListener('touchcancel', function() {
  hoverWall = null;
  touchStartPos = null;
  draw();
});

// Prevent pull-to-refresh / bounce
document.addEventListener('touchmove', function(e) {
  if (e.target === canvas || canvas.contains(e.target)) {
    e.preventDefault();
  }
}, { passive: false });

// Keyboard shortcuts
document.addEventListener('keydown', function(e) {
  if (!gameStarted) return;
  if (e.key === 'm' || e.key === 'M') setMode('move');
  if (e.key === 'w' || e.key === 'W') setMode('wall');
  if (e.key === 'h' || e.key === 'H') setOrientation('h');
  if (e.key === 'v' || e.key === 'V') setOrientation('v');
  if (e.key === 'r' || e.key === 'R') resetGame();
});

// Resize handler
let resizeTimer;
window.addEventListener('resize', function() {
  clearTimeout(resizeTimer);
  resizeTimer = setTimeout(function() {
    if (gameStarted) { resizeBoard(); }
  }, 150);
});
window.addEventListener('orientationchange', function() {
  setTimeout(function() { if (gameStarted) resizeBoard(); }, 300);
});

// ============ INIT ============
initState();
resizeBoard();
updateUI();
draw();

// ============ SERVICE WORKER ============
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('sw.js').then(function(reg) {
    reg.addEventListener('updatefound', function() {
      var newWorker = reg.installing;
      if (newWorker) {
        newWorker.addEventListener('statechange', function() {
          if (newWorker.state === 'activated') {
            if (!gameStarted || gameOver) {
              location.reload();
            }
          }
        });
      }
    });
  }).catch(function() {});
  navigator.serviceWorker.addEventListener('controllerchange', function() {
    if (!gameStarted || gameOver) {
      location.reload();
    }
  });
}
</script>
</body>
</html>
